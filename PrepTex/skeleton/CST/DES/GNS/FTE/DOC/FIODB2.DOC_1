		MODULO FIO PARA DB2
		-------------------


I.- Implementacion de comandos

- FIO-GET-KEY

	SELECT {tabla}
	INTO {campo1},...,{campon}
	WHERE {columna_llave} = {campo_llave}

- FIO-GET-NXT

	a) SELECT {tabla}
	   INTO {campo1},...,{campon}
	   WHERE {columna_llave} >= {campo_llave} AND {campo_llave} + 1
	b) FETCH

- FIO-GET-FST

	MOVE SPACES TO {campo_llave}
	SELECT {tabla}
	INTO {campo1},...,{campon}
	WHERE {columna_llave} >= {campo_llave} AND {campo_llave} + 1

- FIO-GET-NLS

	SELECT {tabla}
	INTO {campo1},...,{campon}
	WHERE {columna_llave} >= {campo_llave} AND {campo_llave} + 1

- FIO-GET-GRT

	SELECT {tabla}
	WHERE {columna_llave} > {campo_llave}	<---- caro

En el caso de los GET se debe hacer un SELECT por cada
campo llave del registro

- FIO-PUT

	INSERT INTO {tabla}
               [({columna1},...,{columnan})]
	VALUES ({campo1},..,{campon})

	donde {campoi} es el campo en el registro

	DISCUSION: acepta cualificar el campo como en COBOL ?
		   el manual dice que se cualifica ESTRUCTURA.
                   que campos se van a definir como columnas en las {tablas} ?

- FIO-MOD

	UPDATE {tabla}
	SET {columna1} = {campo1}
		.
		.
	    {columnan} = {campon}
	WHERE {columna_llave} = {campo_llave}

	DISCUSION:

	. como obtener los nombres de {columnas}
	. obtener el nombre del campo en el registro asociado a un determinado
	  nombre de columna, se debe hacer por norma.
	  El nombre de una columna es de un largo maximo de 18 caracteres,
	  el manual no dice nada si acepta guiones, underscores o similar.
	  Ademas en el registro se debe indicar de algun modo que campo
	  posee una columna relacionada ( cual nivel en el registro ).

- FIO-DEL

	DELETE {tabla}
	WHERE {columna_llave} = {campo_llave}

	Se debe definir por que {campos_llave} se puede eliminar un
	registro, para definir tantos DELETE como sea necesario

- FIO-CHG

	Propongo no implementarlo, por lo menos en una primera etapa,
	hoy dia no esta implementado en DATACOM

- FIO-INP

	a) Dejarlo como DUMMY como hoy dia esta en DATACOM
	b) Asociarlo a un comando DECLARE CURSOR y OPEN

		Este seria el caso en que se defina un archivo logico
		( se define una fio para ese archivo como si fuera un
		archivo mas ) se define para el tanto el archivo
		fisico como la condicion que lo genera, por lo
		tanto el comando INP, seria un :

		DECLARE {cursor} CURSOR FOR
			SELECT *
			FROM {tabla}
			WHERE {condicion}
		OPEN {cursor}

- FIO-OUT

	Dejarlo como DUMMY como hoy dia esta en DATACOM

- FIO-UPD

	a) Dejarlo como DUMMY como hoy dia esta en DATACOM
	b) Asociarlo a un comando DECLARE CURSOR con UPDATE y OPEN

		Este seria el caso en que se defina un archivo logico
		( se define una fio para ese archivo como si fuera un
		archivo mas ) se define para el tanto el archivo
		fisico como la condicion que lo genera y los campos
		que pueden ser modificados, por lo tanto el comando INP,
		seria un :

		DECLARE {cursor} CURSOR
			SELECT *
			FROM {tabla}
			WHERE {condicion}
			FOR UPDATE OF {columna1},...,{columnan}
		OPEN {cursor}

- FIO-CLO

	a) Dejarlo como DUMMY como hoy dia esta en DATACOM
	b) Asociarlo a un comando CLOSE CURSOR para aquellos archivos
	   que se hayan definido logicamente como un CURSOR

		CLOSE {cursor}

- FIO-FND-EQL

	No existe nada similar, dejarlo como no implementado

- FIO-FND-FST

	No existe nada similar, dejarlo como no implementado

- FIO-FND-NLS

	No existe nada similar, dejarlo como no implementado

- FIO-FND-GRT

	No existe nada similar, dejarlo como no implementado

- FIO-ULK-REC

	a) Dejarlo DUMMY
	b) dejarlo como no implementado

- FIO-VID

	a) dejarlo como DUMMY
	b) dejarlo como no implementado

- FIO-ACC

	a) dejarlo como DUMMY
	b) dejarlo como no implementado


- FIO-REC-LCK

	a) dejarlo como DUMMY
	b) dejarlo como no implementado

- FIO-FNF

	a) dejarlo como DUMMY
	b) dejarlo como no implementado

- FIO-REC-LEN

	a) dejarlo como DUMMY
	b) dejarlo como no implementado

- FIO-EXT

	Dejarlo como DUMMY como hoy dia esta en DATACOM

- FIO-END-BRW

	Dejarlo como DUMMY como hoy dia esta en DATACOM

- FIO-BCK-OUT

	ROLLBACK

- FIO-GET-LEQ

	SELECT {tabla}
	WHERE {columna_llave} <= {campo_llave} AND > {campo_llave} - 1

- FIO-GET-PRV

	Dejarlo no implementado

- FIO-CHK-PNT

	COMMIT

- FIO-BFR-RFH

	DUMMY

II.- NOTAS:

- Uso de correlativos

a) para GET-NXT

	| 1 | CIC |
	| 2 | CIC | ...

   Para hacer GET-NXT se deberia guardar el correlativo anterior por cada
   FIO, luego sumar 1 al correlativo y hacer un GET-KEY.
   No permite eliminar registros, por otro lado como los
   correlativos se deberian asignar de acuerdo al orden ascendente por
   llave y los registros no se van grabando en la base de datos de esa
   manera, por lo tanto lo considero impracticable.


b) para hacer GET-NLS

	| CIC | 1
	| CIC | 2
	| CIC | 3

   SELECT {tabla}
   WHERE {columna_llave} >= {campo_llave} AND < {campo_llave} + 1

   asume que siempre despues del {campo_llave}n viene el
   {campo_llave}n+1 lo que no necesariamente es cierto. esto se aplica para
    todos los comando que leen de esta manera (GET-FST,GET-NXT)

   Lo mismo se aplica para el GET-LEQ, ademas no sirve para el codigo
   que tenemos escrito ya que siempre movemos un 999 al correlativo
   ya que no sabemos cual es el ultimo, a diferencia del GET-NLS en
   donde podriamos asumir que siempre el primero es el 001, pero
   en este caso si ya asumimos que el primero es el 1 entonces mejor
   leer con GET-KEY.

   Proposicion :

   Nosotros siempre usamos el GET-NLS para empezar a leer un grupo de
   registros, llenando la primera parte ( CIC ) con el valor correspondiente,
   luego llenamos el correlativo con cero y leemos por mayor o igual para
   despues empezar a leer el resto de los registros del mismo grupo ( CIC ).
   La proposicion es que la FIO de alguna manera conozca la primera parte
   de la llave ( es decir el CIC ) y en vez de leer por mayor o igual
   haga un SELECT en un DECLARE CURSOR para todos aquellos que cumplen
   igualdad en el 'CIC' haciendo un BY ORDER por correlativo y luego un FETCH
   para entregar el primer registro, a su vez tambien se deberia implementar
   el comando GET-NXT como FETCH ( estoy pensando en el codigo adicional que
   ya tenemos escrito ), la FIO deberia marcar la primera vez que
   se invoca con GET-NLS para hacer el DECLARE CURSOR y OPEN CURSOR, asi en
   las siguientes veces que se invoque hacer un CLOSE CURSOR y un OPEN CURSOR.


- FIO-GET-LEQ

   Analogamente al GET-NLS, implementar este comando con un DECLARE CURSOR
   con un SELECT para todos aquellos que cumplen igualdad en la llave y
   con un ORDER BY descendente por correlativo y luego un FETCH para entregar
   el primer registro, tambien en esta caso el GET-PRV se deberia implementar
   con FETCH.

- FIO-GET-GRT

   Hoy dia en DATACOM no esta implementado, propongo dejarlo igaul en DB2

III.- Miscelaneos

	. Uso de WHENEVER v/s SQLCODE de la SQLCA
	. Performance TABLAS(registros) v/s VIEWS
