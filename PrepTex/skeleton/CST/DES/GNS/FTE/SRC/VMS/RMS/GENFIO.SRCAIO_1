100
	DECLARE INTEGER NUMTOKEN,	SC_NUMTOKEN	,&
			SZTOKEN	, 	SC_SZTOKEN	,&
			TOKEN	,	SC_TOKEN 	,&
			P_P	,	SC_P_P		,&
			P_Q	,	SC_P_Q 		,&
			SZ_I_B

	DECLARE	STRING	C_Q	,	SC_C_Q		,&
			VALTOKEN,	SC_VALTOKEN	,&
			STRTOKEN

	DECLARE INTEGER	CONSTANT &
			KEYTOK = 1,	IDNTOK = 2	,&
			NUMTOK = 3,	STRTOK = 4	,&
			CHRTOK = 5,	EOLTOK = 6	,&
			ETXTOK = 7,	HTAB   = 9

	DECLARE INTEGER &
			FIO_NUM_KYS,	NEWE_NTRY 

	DECLARE STRING  &
			ASCI_BELL,	FILE_FDL	,&
			VARI_ABPA,	VARI_CIPA	,&
			REGI_STRO,	VARI_LLAV	,&
			O_L,		A_K		,&
			TIPO_ARCH,	NOMB_ARCH	,&
			C_M,		VARI_FIND	,&
			FILE_ALT,	VARI_ALKY	,&
			A_T (20)			,&
			FILE_FND,	SIST_EMA	,&
			VARI_RESU,	AUXI_FDL	,&
			FILE_EDT,	SIZE_KEY	,&
			FILE_MOV,	FILE_EDI	,&
			AUXI_ALTE,	WITH_DUPL	,&
			PARA_METRO,	W_DEP		,&
			W_VAR,		V_M(5)		,&
			FIO_GLS_VAI			,&
			FIO_GLS_KYS(20)

   DECLARE INTEGER CONSTANT &
					INX_NAME  =  1	,&
			INX_ORGA  =  2,	INX_FORM  =  3	,&
			INX_SIZE  =  4,	FIO_NUM_PKY  =  1,&
			INX_ACCE  =  6, INX_ALTE  =  7	,&
			INX_TIAR  =  8, INX_PNTO  =  7	,&
			NO	  =  0,	ZI	  =  1	,&
			MG_C	  =  1,	MG_A	  =  2	,&
			MG_B	  =  3, MG_1	  =  4  ,&
			MG_2	  =  5

210
 !==========================================================================
    DEF INTEGER NEXTTOKEN
	ON ERROR GO TO LABE_ERRO
	IF TOKEN = ETXTOK THEN
		NEXTTOKEN = ETXTOK
		GO TO LABE_ASIG
	END IF
        P_P = P_Q 
 LABE_SIGA:
	WHILE (MID$(I_B$,P_P,1) = " " OR ASCII(MID$(I_B$,P_P,1)) = HTAB) AND &
			P_P <= SZ_I_B
		P_P = P_P + 1
	NEXT
	P_Q = P_P 
	IF P_P > SZ_I_B OR I_B$ = "" THEN
		GET #C_FILE_FDL%
		SZ_I_B = RECOUNT
	     	MOVE FROM #C_FILE_FDL% , I_B$ = SZ_I_B
		P_P, P_Q  = 1
		GO TO LABE_SIGA
	END IF
	C_Q = MID$(I_B$,P_Q,1)
	IF (C_Q >= "A" AND C_Q <= "Z") OR (C_Q >= "a" AND C_Q <= "z") THEN
	         WHILE (MID$(I_B$,P_P,1) >= "A" AND MID$(I_B$,P_P,1) <= "Z" &
	            OR  MID$(I_B$,P_P,1)  = "_" 	  &
	            OR  MID$(I_B$,P_P,1)  = "0" 	  &
		    OR  MID$(I_B$,P_P,1) >= "a" AND &
		        MID$(I_B$,P_P,1) <= "z")
	            			P_P = P_P + 1
		 NEXT
	         SZTOKEN = P_P - P_Q
		 NEXTTOKEN = IDNTOK
	   	 VALTOKEN = MID$(I_B$,P_Q,SZTOKEN)
		 IF P_Q = 1 THEN
			NEWE_NTRY = ZI
		 END IF
	ELSE
	IF C_Q >= "0" AND C_Q <= "9" THEN
	          WHILE MID$(I_B$,P_P,1) >= "0" AND MID$(I_B$,P_P,1) <= "9"
		             P_P = P_P + 1
	          NEXT
	          SZTOKEN = P_P - P_Q
		  NEXTTOKEN = NUMTOK
		  VALTOKEN = MID$(I_B$,P_Q,SZTOKEN)
	          NUMTOKEN  = VAL(VALTOKEN)
	ELSE
	IF C_Q = '"'  OR C_Q = "'" THEN
		P_P = P_P + 1
	        WHILE MID$(I_B$,P_P,1) <> C_Q
  	              P_P = P_P + 1
	        NEXT
	        SZTOKEN = P_P - (P_Q + 1)
	        P_P = P_P + 1
		NEXTTOKEN = STRTOK
		STRTOKEN = MID$(I_B$,P_Q + 1,SZTOKEN)
		VALTOKEN = C_Q + STRTOKEN + C_Q
	ELSE
		NEXTTOKEN = CHRTOK
		VALTOKEN = MID$(I_B$,P_P,1)
		P_P = P_P + 1
		SZTOKEN = 1
	END IF
	END IF
	END IF
	GO TO LABE_ASIG
 LABE_ERRO:
	CLOSE #C_FILE_FDL%
	IF ERR = 11 THEN
		NEXTTOKEN = ETXTOK
	ELSE
		PRINT "ERROR(";ERR;") ";ERT$(ERR);" en linea ";erl;", MODULO ";ern$
	END IF
	RESUME 800
 LABE_ASIG:
	P_Q = P_P
800
	END DEF

 !==========================================================================

   DEF INTEGER FUNC_NAME
	NEWE_NTRY = NO
	WHILE NEWE_NTRY = NO AND TOKEN <> ETXTOK
		TOKEN = NEXTTOKEN
		IF VALTOKEN = "NAME" THEN
			TOKEN = NEXTTOKEN
			POSI_PNTO% = INSTR(1,STRTOKEN,".")
			POSI_DOSP% = INSTR(1,STRTOKEN,":")
			VARI_RESU = STRTOKEN
			IF POSI_PNTO% = 0 THEN
				CANT_CHAR% = LEN(STRTOKEN) - POSI_DOSP%
			ELSE
				CANT_CHAR% = POSI_PNTO% - POSI_DOSP% - 1
			END IF
			NOM_LOG$ = MID$(STRTOKEN,1,POSI_DOSP% - 1)
			NOM_FIS$ = MID$(STRTOKEN,POSI_DOSP% + 1,CANT_CHAR%)
			IF NOM_FIS$ <> "" THEN
				SIST_EMA = MID$(NOM_FIS$,1,3)
				A_T(INX_NAME) = MID$(NOM_FIS$,4,LEN(STRTOKEN) -3)
			ELSE
				SIST_EMA = MID$(NOM_LOG$,1,3)
				A_T(INX_NAME) = MID$(NOM_LOG$,4,LEN(STRTOKEN) -3)
			END IF	
			IF A_T(INX_NAME) = "" THEN
				CALL GENFIOERR(INX_NAME)
			END IF
		ELSE
		IF VALTOKEN = "ORGANIZATION" THEN
			TOKEN = NEXTTOKEN
			IF VALTOKEN = "indexed" THEN
				A_T(INX_TIAR) = "IDX"
			ELSE
			IF VALTOKEN = "sequential" THEN
				A_T(INX_TIAR) = "SEQ"
			ELSE
			IF VALTOKEN = "relative" THEN
				A_T(INX_TIAR) = "REL"
			END IF
			END IF
			END IF
		END IF
		END IF
	NEXT
   END DEF

 !==================================================================

   DEF INTEGER FUNC_REGI
	NEWE_NTRY = NO
	WHILE NEWE_NTRY = NO AND TOKEN <> ETXTOK
		TOKEN = NEXTTOKEN
		IF VALTOKEN = "FORMAT" THEN
			TOKEN = NEXTTOKEN
			A_T(INX_FORM) = VALTOKEN
		ELSE
		IF VALTOKEN = "SIZE" THEN
			TOKEN = NEXTTOKEN
			A_T(INX_SIZE) = VALTOKEN
		END IF
		END IF
	NEXT
   END DEF	

 !==================================================================
   DEF INTEGER FIO_GET_KEY_ALT
	VARI_ALKY = 							  O_L +&
	V_M(MG_A) + 'GET-KEY-ALT SECTION.'				+ O_L +&
	V_M(MG_A) + 'INI-GET-KEY-ALT.'
	PRINT #C_FILE_FND%,VARI_ALKY
	VARI_ALKY = ''
	PRINT #C_FILE_FND%,V_M(MG_B) + 'MOVE LNK-REGI TO ^reg^.'

   FOR I% = 1 TO FIO_NUM_KYS
	VARI_ALKY = VARI_ALKY + &
	V_M(MG_B) +	'IF FIO-AKEY = ' + C_M + FIO_GLS_KYS(I%) + C_M	+ O_L +&
	V_M(MG_1) +     	'START ^sis^^reg^ KEY EQUAL ' +&
				FIO_GLS_KYS(I%) + ' IN ^sis^^reg^' 	+ O_L +&
	V_M(MG_B) +	'ELSE'						+ O_L
   NEXT I%
	VARI_ALKY = VARI_ALKY + &
	V_M(MG_1) + 'GO TO ERR-ALT.'					+ O_L +&
	V_M(MG_B) + 'IF FIO-STAT-OKS'					+ O_L +&
	V_M(MG_1) +	'GO TO INI-GET-NXT.'				+ O_L +&
	V_M(MG_A) + 'FIN-GET-KEY-ALT.'					+ O_L +&
	V_M(MG_B) +	'EXIT PROGRAM.'
	PRINT #C_FILE_FND%,VARI_ALKY
	VARI_ALKY = ''
   END DEF
 !==================================================================


   DEF INTEGER FIO_GET_FST_ALT
	PRINT #C_FILE_FND%,''
	PRINT #C_FILE_FND%,V_M(MG_A) + 'GET-FST-ALT SECTION.'
	PRINT #C_FILE_FND%,V_M(MG_A) + 'INI-GET-FST-ALT.'
	PRINT #C_FILE_FND%,V_M(MG_B) +      'PERFORM INI-FND-FST-ALT.'
	PRINT #C_FILE_FND%,V_M(MG_B) +      'IF FIO-STAT-OKS'
	PRINT #C_FILE_FND%,V_M(MG_B) +      '    GO TO INI-GET-NXT.'
	PRINT #C_FILE_FND%,V_M(MG_A) + 'FIN-GET-FST-ALT.'
	PRINT #C_FILE_FND%,V_M(MG_B) +      'EXIT PROGRAM.'
   END DEF

 !==================================================================

   DEF INTEGER FIO_GET_NLS_ALT
	PRINT #C_FILE_FND%,''
	PRINT #C_FILE_FND%,V_M(MG_A) + 'GET-NLS-ALT SECTION.'
	PRINT #C_FILE_FND%,V_M(MG_A) + 'INI-GET-NLS-ALT.'
	PRINT #C_FILE_FND%,V_M(MG_B) +      'PERFORM INI-FND-NLS-ALT.'
	PRINT #C_FILE_FND%,V_M(MG_B) +      'IF FIO-STAT-OKS'
	PRINT #C_FILE_FND%,V_M(MG_B) +      '    GO TO INI-GET-NXT.'
	PRINT #C_FILE_FND%,V_M(MG_A) + 'FIN-GET-NLS-ALT.'
	PRINT #C_FILE_FND%,V_M(MG_B) +      'EXIT PROGRAM.'
   END DEF

 !==================================================================

   DEF INTEGER FIO_GET_GRT_ALT
	PRINT #C_FILE_FND%,''
	PRINT #C_FILE_FND%,V_M(MG_A) + 'GET-GRT-ALT SECTION.'
	PRINT #C_FILE_FND%,V_M(MG_A) + 'INI-GET-GRT-ALT.'
	PRINT #C_FILE_FND%,V_M(MG_B) +      'PERFORM INI-FND-GRT-ALT.'
	PRINT #C_FILE_FND%,V_M(MG_B) +      'IF FIO-STAT-OKS'
	PRINT #C_FILE_FND%,V_M(MG_B) +      '    GO TO INI-GET-NXT.'
	PRINT #C_FILE_FND%,V_M(MG_A) + 'FIN-GET-GRT-ALT.'
	PRINT #C_FILE_FND%,V_M(MG_B) +      'EXIT PROGRAM.'
   END DEF

 !==================================================================

   DEF INTEGER FIO_FND_EQL_ALT
	VARI_ALKY = ''
	PRINT #C_FILE_FND%,''
	PRINT #C_FILE_FND%,V_M(MG_A) + 'FND-EQL-ALT SECTION.'
	PRINT #C_FILE_FND%,V_M(MG_A) + 'INI-FND-EQL-ALT.'
	PRINT #C_FILE_FND%,V_M(MG_B) + 'MOVE LNK-REGI TO ^reg^.'
   FOR I% = 1 TO FIO_NUM_KYS
	VARI_ALKY = VARI_ALKY + &
	V_M(MG_B) +	'IF FIO-AKEY = ' + C_M + FIO_GLS_KYS(I%) + C_M	+ O_L +&
	V_M(MG_1) +		'START ^sis^^reg^ KEY EQUAL ' +&
				FIO_GLS_KYS(I%) + ' IN ^sis^^reg^'	+ O_L +&
	V_M(MG_B) +	'ELSE'						+ O_L
   NEXT I%
	VARI_ALKY = VARI_ALKY + &
	V_M(MG_1) + 'GO TO ERR-ALT.'					+ O_L +&
	V_M(MG_A) + 'FIN-FND-EQL-ALT.'					+ O_L +&
	V_M(MG_B) +	'EXIT PROGRAM.'
	PRINT #C_FILE_FND%,VARI_ALKY
	VARI_ALKY = ''
   END DEF

 !==================================================================

   DEF INTEGER FIO_FND_FST_ALT
	VARI_ALKY = 							  O_L +&
	V_M(MG_A) + 'FND-FST-ALT SECTION.'				+ O_L +&
	V_M(MG_A) + 'INI-FND-FST-ALT.'					+ O_L
   FOR I% = 1 TO FIO_NUM_KYS
	VARI_ALKY = VARI_ALKY + &
	V_M(MG_B) +	'IF FIO-AKEY = ' + C_M + FIO_GLS_KYS(I%) + C_M	+ O_L +&
	V_M(MG_1) + 		'INITIALIZE ^key^ IN ^sis^^reg^'	+ O_L +&
	V_M(MG_1) +		'START ^sis^^reg^ KEY NOT LESS ' +&
				FIO_GLS_KYS(I%) + ' IN ^sis^^reg^'	+ O_L +&
	V_M(MG_B) +	'ELSE'						+ O_L
   NEXT I%
	VARI_ALKY = VARI_ALKY + &
	V_M(MG_1) + 'GO TO ERR-ALT.'					+ O_L +&
	V_M(MG_A) + 'FIN-FND-FST-ALT.'					+ O_L +&
	V_M(MG_B) +	'EXIT PROGRAM.'
	PRINT #C_FILE_FND%,VARI_ALKY
	VARI_ALKY = ''
   END DEF

 !==================================================================

   DEF INTEGER FIO_FND_NLS_ALT
	VARI_ALKY = ''
	PRINT #C_FILE_FND%,''
	PRINT #C_FILE_FND%,V_M(MG_A) + 'FND-NLS-ALT SECTION.'
	PRINT #C_FILE_FND%,V_M(MG_A) + 'INI-FND-NLS-ALT.'
	PRINT #C_FILE_FND%,V_M(MG_B) +     'MOVE LNK-REGI TO ^reg^.'
   FOR I% = 1 TO FIO_NUM_KYS
	VARI_ALKY = VARI_ALKY + &
	V_M(MG_B) +	'IF FIO-AKEY = ' + C_M + FIO_GLS_KYS(I%) + C_M	+ O_L +&
	V_M(MG_1) +		'START ^sis^^reg^ KEY NOT LESS ' +&
				FIO_GLS_KYS(I%) + ' IN ^sis^^reg^'	+ O_L +&
	V_M(MG_B) +	'ELSE'						+ O_L
   NEXT I%
	VARI_ALKY = VARI_ALKY + &
	V_M(MG_1) + 'GO TO ERR-ALT.'					+ O_L +&
	V_M(MG_A) + 'FIN-FND-NLS-ALT.'					+ O_L +&
	V_M(MG_B) +	'EXIT PROGRAM.'
	PRINT #C_FILE_FND%,VARI_ALKY
	VARI_ALKY = ''
   END DEF

 !==================================================================

   DEF INTEGER FIO_FND_GRT_ALT
	VARI_ALKY = ''
	PRINT #C_FILE_FND%,''
	PRINT #C_FILE_FND%,V_M(MG_A) + 'FND-GRT-ALT SECTION.'
	PRINT #C_FILE_FND%,V_M(MG_A) + 'INI-FND-GRT-ALT.'
	PRINT #C_FILE_FND%,V_M(MG_B) +     'MOVE LNK-REGI TO ^reg^.'
   FOR I% = 1 TO FIO_NUM_KYS
	VARI_ALKY = VARI_ALKY + &
	V_M(MG_B) +	'IF FIO-AKEY = ' + C_M + FIO_GLS_KYS(I%) + C_M	+ O_L +&
	V_M(MG_1) +		'START ^sis^^reg^ KEY GREATER ' +&
				FIO_GLS_KYS(I%) + ' IN ^sis^^reg^'	+ O_L +&
	V_M(MG_B) + 	'ELSE'						+ O_L
   NEXT I%
	VARI_ALKY = VARI_ALKY + &
	V_M(MG_1) + 'GO TO ERR-ALT.'					+ O_L +&
	V_M(MG_A) + 'FIN-FND-GRT-ALT.'					+ O_L +&
	V_M(MG_B) +	'EXIT PROGRAM.'
	PRINT #C_FILE_FND%,VARI_ALKY
	VARI_ALKY = ''
   END DEF

 !==================================================================

   DEF INTEGER FUNC_ALTE
	FIO_NUM_FNC = FIO_GET_KEY_ALT
	FIO_NUM_FNC = FIO_GET_FST_ALT
	FIO_NUM_FNC = FIO_GET_NLS_ALT
	FIO_NUM_FNC = FIO_GET_GRT_ALT
	FIO_NUM_FNC = FIO_FND_EQL_ALT
	FIO_NUM_FNC = FIO_FND_FST_ALT
	FIO_NUM_FNC = FIO_FND_NLS_ALT
	FIO_NUM_FNC = FIO_FND_GRT_ALT
   END DEF
 !==================================================================

   DEF INTEGER FUNC_LLAV
      NEWE_NTRY = NO
      WITH_DUPL = ''
      WHILE NEWE_NTRY = NO AND TOKEN <> ETXTOK
	TOKEN = NEXTTOKEN
	IF VALTOKEN = 'NAME' THEN
		TOKEN = NEXTTOKEN
		FIO_NUM_KYS = FIO_NUM_KYS + 1
		FIO_GLS_KYS(FIO_NUM_KYS) = STRTOKEN
		A_K = STRTOKEN
		IF FIO_NUM_KYS = 1 THEN
			A_T(INX_ALTE) = V_M(MG_B) + "MOVE WSS-VKEY TO " + STRTOKEN
			WHILE NEWE_NTRY = NO AND TOKEN <> ETXTOK AND &
					VALTOKEN <> "SEG0_LENGTH"
				TOKEN = NEXTTOKEN
			NEXT
			TOKEN = NEXTTOKEN
			SIZE_KEY = SIZE_KEY + VALTOKEN
		ELSE
			A_T(INX_ALTE) = A_T(INX_ALTE) + O_L + V_M(MG_2) +&
					V_M(MG_B) + STRTOKEN
			AUXI_ALTE = V_M(MG_B) + "ALTERNATE RECORD KEY IS "+&
					A_K + " IN " + SIST_EMA + A_T(INX_NAME)
		END IF
	ELSE
	IF VALTOKEN = 'DUPLICATES' THEN
		TOKEN = NEXTTOKEN
		WITH_DUPL = ''
		IF VALTOKEN = 'yes' AND FIO_NUM_KYS <> 0 THEN
			WITH_DUPL = V_M(MG_B) + 'WITH DUPLICATES'
		END IF
	END IF
	END IF
      NEXT
	AUXI_ALTE = AUXI_ALTE
	IF FIO_NUM_KYS > 1 THEN
		PRINT #C_FILE_ALT%, AUXI_ALTE
                IF WITH_DUPL <> '' THEN
			PRINT #C_FILE_ALT%, WITH_DUPL
                END IF
	END IF
    END DEF

 !==================================================================

   DEF INTEGER GRAB_ARC

	FILE_EDT = 'FIO' + AUXI_FDL + '.EDT'
	OPEN FILE_EDT FOR OUTPUT AS FILE #C_FILE_EDT%,ORGANIZATION SEQUENTIAL &
		VARIABLE , RECORDSIZE 255, RECORDTYPE ANY

	PRINT #C_FILE_EDT%, 'FIND "^alt^"'
	PRINT #C_FILE_EDT%, 'DELETE'
	PRINT #C_FILE_EDT%, 'INC ' + FILE_ALT
	PRINT #C_FILE_EDT%, 'FIND "^fnd^"'
	PRINT #C_FILE_EDT%, 'DELETE'
	PRINT #C_FILE_EDT%, 'INC ' + FILE_FND
	PRINT #C_FILE_EDT%, 'S/^reg^/' + A_T(INX_NAME)		  + '/W/NOTYPE'
	PRINT #C_FILE_EDT%, 'S/^key^/' + FIO_GLS_KYS(FIO_NUM_PKY) + '/W/NOTYPE'
	PRINT #C_FILE_EDT%, 'S/^var^/' + W_VAR			  + '/W/NOTYPE'
	PRINT #C_FILE_EDT%, 'S/^rsz^/' + A_T(INX_SIZE)		  + '/W/NOTYPE'
	PRINT #C_FILE_EDT%, 'S/^dep^/' + W_DEP			  + '/W/NOTYPE'
	PRINT #C_FILE_EDT%, 'S/^sis^/' + SIST_EMA		  + '/W/NOTYPE'
	PRINT #C_FILE_EDT%, 'S/^vid^/' + VARI_RESU		  + '/W/NOTYPE'
	PRINT #C_FILE_EDT%, 'S/^ksz^/' + SIZE_KEY		  + '/W/NOTYPE'
	PRINT #C_FILE_EDT%, 'EXIT'
	CLOSE #C_FILE_EDT%

	FILE_EDI = 'PRU' + AUXI_FDL + '.EDT'
	OPEN FILE_EDI FOR OUTPUT AS FILE #C_FILE_EDI%,ORGANIZATION SEQUENTIAL &
		VARIABLE , RECORDSIZE 255, RECORDTYPE ANY

	PRINT #C_FILE_EDI%, 'FIND "^alt^"'
	PRINT #C_FILE_EDI%, 'DELETE'
	PRINT #C_FILE_EDI%, 'INC ' + FILE_MOV
	PRINT #C_FILE_EDI%, 'S/^reg^/' + A_T(INX_NAME)	+ '/W/NOTYPE'
	PRINT #C_FILE_EDI%, 'S/^sis^/' + SIST_EMA	+ '/W/NOTYPE'
	PRINT #C_FILE_EDI%, 'EXIT'
	CLOSE #C_FILE_EDI%

   END DEF

 ! ------------------------------------------------------------------
 !               MODULO PRINCIPAL
 ! __________________________________________________________________


	ON ERROR GO TO  LABE_BADD
	ASCI_BELL = CHR$(07)
	O_L = CHR$(13) + CHR$(10)
	C_FILE_FDL% = 1	
	C_FILE_ALT% = 2
	C_FILE_FND% = 4
	C_FILE_MOV% = 5
	C_FILE_EDT% = 6
	C_FILE_EDI% = 7
	SIZE_KEY = "0"
	C_M = "'"

	CALL LIB$GET_SYMBOL("PTH",FILE_FDL)
	CALL LIB$GET_SYMBOL("FIL",AUXI_FDL)
	V_M(MG_C) = "      "
	V_M(MG_A) = "       "
	V_M(MG_B) = "           "
	V_M(MG_1) = "              "
	V_M(MG_2) = "                "
	FIO_GLS_VAI = 'INITIALIZE '

	OPEN FILE_FDL FOR INPUT  AS FILE #C_FILE_FDL%,	RECORDSIZE 255, &
	             ORGANIZATION SEQUENTIAL VARIABLE, 	RECORDTYPE ANY

	FILE_ALT = "FIO" + AUXI_FDL + ".ALT"
	OPEN FILE_ALT FOR OUTPUT AS FILE #C_FILE_ALT%,	RECORDSIZE 255, &
		     ORGANIZATION SEQUENTIAL VARIABLE,	RECORDTYPE ANY

	FILE_FND = "FIO" + AUXI_FDL + ".FND"
	OPEN FILE_FND FOR OUTPUT AS FILE #C_FILE_FND%,	RECORDSIZE 255, &
		     ORGANIZATION SEQUENTIAL VARIABLE,	RECORDTYPE ANY

	FILE_MOV = "FIO" + AUXI_FDL + ".MOV"
	OPEN FILE_MOV FOR OUTPUT AS FILE #C_FILE_MOV%,	RECORDSIZE 255, &
		     ORGANIZATION SEQUENTIAL VARIABLE,	RECORDTYPE ANY

	GET #C_FILE_FDL%
	SZ_I_B  = RECOUNT
	MOVE FROM #C_FILE_FDL% , I_B$ = SZ_I_B
	P_P,P_Q = 1
	WHILE TOKEN <> ETXTOK
		IF TOKEN = IDNTOK AND VALTOKEN = "FILE" THEN
			INDI_ACCI = FUNC_NAME
		ELSE
		IF TOKEN = IDNTOK AND VALTOKEN = "RECORD" THEN
			INDI_ACCI = FUNC_REGI
		ELSE
		IF TOKEN = IDNTOK AND VALTOKEN = "KEY" THEN
			INDI_ACCI = FUNC_LLAV
		ELSE
			TOKEN = NEXTTOKEN
		END IF
		END IF
		END IF
	NEXT

	TIPO_ARCH = A_T(INX_TIAR)
	NOMB_ARCH =  SIST_EMA + A_T(INX_NAME)

	IF A_T(INX_SIZE) = "" THEN
		CALL GENFIOERR(INX_SIZE)
	ELSE
	IF TIPO_ARCH = "IDX" AND A_T(FIO_NUM_PKY) = "" THEN
		CALL GENFIOERR(FIO_NUM_PKY)
	END IF
	END IF
	IF TIPO_ARCH = "IDX" THEN
		A_T(INX_ALTE) = A_T(INX_ALTE) + "."
		PRINT #C_FILE_MOV%,A_T(INX_ALTE)
	END IF
	IF A_T(INX_FORM) = "variable" THEN
		W_VAR = "VARYING TO "
		W_DEP = " DEPENDING FIO-RLEN"
	ELSE
		W_VAR = ""
		W_DEP = ""
	END IF
	
	INDI_ACCI = GRAB_ARC
	IF TIPO_ARCH = "IDX" THEN
		INDI_ACCI = FUNC_ALTE
	END IF
	CLOSE #C_FILE_FND%
	CLOSE #C_FILE_MOV%
	CLOSE #C_FILE_ALT%
	PARA_METRO = '$ EDTFIO ' + AUXI_FDL + ' ' + TIPO_ARCH + ' ' +&
				SIST_EMA + ' ' + A_T(INX_NAME)
	CALL LIB$DO_COMMAND(PARA_METRO)
	GO TO LABE_ATRA
		
 LABE_BADD:
	PRINT ASCI_BELL,ASCI_BELL,ASCI_BELL
	PRINT "Error     "
	PRINT "=====     "
	PRINT "Codigo  : ",ERR
	PRINT "Mensaje : ",ERT$(ERR)
	CALL SYS$EXIT(0)
	RESUME 999
999

 LABE_ATRA:
 END
