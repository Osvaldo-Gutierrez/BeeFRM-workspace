$SET SHARING = PRIVATE
$RESET DEBUG
BEGIN
$SET OMIT = NOT DEBUG
  EBCDIC ARRAY BUG_ARRAY [0:500];
  ARRAY ABUG[0:0];
  INTEGER IBUG;
  HEX ARRAY HBUG[0] = ABUG;
$POP OMIT
  DEFINE C = , #;
  DEFINE  DEBUGER(MSG) =
$SET OMIT = NOT DEBUG
          REPLACE BUG_ARRAY BY " " FOR SIZE(BUG_ARRAY);
          REPLACE BUG_ARRAY
               BY TIME(7).[23:06] FOR 2 DIGITS,":",
                  TIME(7).[17:06] FOR 2 DIGITS,":",
                  TIME(7).[11:06] FOR 2 DIGITS," ",
                  MSG;
          WRITE(MYSELF.TASKFILE, 22, BUG_ARRAY);
$POP OMIT
        #;
  DEFINE B_BUG(MSG, B) =
$SET OMIT = NOT DEBUG
          ABUG[0] := B;
          REPLACE BUG_ARRAY BY " " FOR SIZE(BUG_ARRAY);
          REPLACE BUG_ARRAY
               BY TIME(7).[23:06] FOR 2 DIGITS,":",
                  TIME(7).[17:06] FOR 2 DIGITS,":",
                  TIME(7).[11:06] FOR 2 DIGITS," ",
                  MSG, ":", HBUG FOR 12 WITH HEXTOEBCDIC;
          WRITE(MYSELF.TASKFILE, 22, BUG_ARRAY);
$POP OMIT
        #;
 DEFINE A_BUG(MSG) =
$SET OMIT = NOT DEBUG
          IBUG := 0;
          WHILE (IBUG < SIZE(MSG) - 1) DO
            BEGIN
            REPLACE BUG_ARRAY BY " " FOR SIZE(BUG_ARRAY);
            REPLACE BUG_ARRAY BY MSG[IBUG] FOR MIN(80,SIZE(MSG)-IBUG);
            IBUG :=* + 80;
            WRITE(MYSELF.TASKFILE, 22, BUG_ARRAY);
            END;
$POP OMIT
        #;
 DEFINE H_BUG(MSG,SZ_MSG) =
$SET OMIT = NOT DEBUG
        BEGIN
          HEX ARRAY HMSG[0] = MSG;
          IBUG := 0;
          WHILE (IBUG < SZ_MSG - 1) DO
            BEGIN
            REPLACE BUG_ARRAY BY " " FOR SIZE(BUG_ARRAY);
            REPLACE BUG_ARRAY
                 BY HMSG[IBUG*2] FOR 12 WITH HEXTOEBCDIC;
            IF (IBUG+6 < SIZE(MSG) - 1) THEN
              REPLACE BUG_ARRAY[13]
                   BY HMSG[IBUG*2+12] FOR 12 WITH HEXTOEBCDIC;
            IF (IBUG+12 < SIZE(MSG) - 1) THEN
              REPLACE BUG_ARRAY[26]
                   BY HMSG[IBUG*2+24] FOR 12 WITH HEXTOEBCDIC;
            IF (IBUG+18 < SIZE(MSG) - 1) THEN
              REPLACE BUG_ARRAY[39]
                   BY HMSG[IBUG*2+36] FOR 12 WITH HEXTOEBCDIC;
            REPLACE BUG_ARRAY[56]
                 BY MSG[IBUG] FOR MIN(24,SIZE(MSG)-IBUG);
            IBUG :=* + 24;
            WRITE(MYSELF.TASKFILE,132, BUG_ARRAY);
            END;
        END
$POP OMIT
        #;
  INTEGER I;
  TASK T1, T2, T3;
  BOOLEAN PRIMERA_LLAMADA_1,
          PRIMERA_LLAMADA_2,
          PRIMERA_LLAMADA_3;
  EBCDIC ARRAY ARREGLO1[0:100],
               ARREGLO2[0:100],
               ARREGLO3[0:100];
  EVENT EVENT1_IN, EVENT1_OUT,
        EVENT2_IN, EVENT2_OUT,
        EVENT3_IN, EVENT3_OUT;
      
  PROCEDURE PARA (EVENT_IN, EVENT_OUT, ARREGLO);
    EVENT  EVENT_IN, EVENT_OUT;
    EBCDIC ARRAY ARREGLO[0];
    BEGIN
    LIBRARY LIB (%TITLE = "(PD016)GNS/EXE/GNSPPLIB ON BCA021."
                  TITLE = "LOP/OBJ/XXXINSFB."
                );
    PROCEDURE GNSPPLIB (E);
      EBCDIC ARRAY E[0];
      LIBRARY LIB(ACTUALNAME="PROCEDUREDIVISION");
      
    DEBUGER("PARALELA INI");
    WHILE (MYSELF.TASKVALUE NEQ 99) DO
      BEGIN
      WAITANDRESET(EVENT_IN);
      IF (MYSELF.TASKVALUE NEQ 99) THEN
        BEGIN
        GNSPPLIB(ARREGLO);
        CAUSE(EVENT_OUT);
        END;
      END;
    DEBUGER("PARALELA EXIT");
    END OF PARA;
      
  PROCEDURE CONSULTA(ACUAL, ARREGLO);
    INTEGER ACUAL;
    EBCDIC ARRAY ARREGLO[0];
    BEGIN
      
    DEBUGER("CONSULTA " C ACUAL FOR * DIGITS);
    H_BUG(ARREGLO, SIZE(ARREGLO));
    CASE ACUAL OF BEGIN
    (3):BEGIN
        IF NOT PRIMERA_LLAMADA_3 THEN
          BEGIN
          PRIMERA_LLAMADA_3 := TRUE;
          IF (SIZE(ARREGLO3) < SIZE(ARREGLO)) THEN
            RESIZE(ARREGLO3, SIZE(ARREGLO));
          END;
        REPLACE ARREGLO3[0]
             BY ARREGLO FOR SIZE(ARREGLO);
        CAUSE(EVENT3_IN);
        END;
    (2):BEGIN
        IF NOT PRIMERA_LLAMADA_2 THEN
          BEGIN
          PRIMERA_LLAMADA_2 := TRUE;
          IF (SIZE(ARREGLO2) < SIZE(ARREGLO)) THEN
            RESIZE(ARREGLO2, SIZE(ARREGLO));
          END;
        REPLACE ARREGLO2[0]
             BY ARREGLO FOR SIZE(ARREGLO);
        CAUSE(EVENT2_IN);
        END;
    (1):BEGIN
        IF NOT PRIMERA_LLAMADA_1 THEN
          BEGIN
          PRIMERA_LLAMADA_1 := TRUE;
          IF (SIZE(ARREGLO1) < SIZE(ARREGLO)) THEN
            RESIZE(ARREGLO1, SIZE(ARREGLO));
          END;
        REPLACE ARREGLO1[0]
             BY ARREGLO FOR SIZE(ARREGLO);
        CAUSE(EVENT1_IN);
        END;
    ELSE:
    END OF CASE;
    DEBUGER("CONSULTA EXIT " C ACUAL FOR * DIGITS C " " C
            ARREGLO FOR 50);
    END OF CONSULTA;
      
  EXPORT CONSULTA;
      
  PROCEDURE RESPUESTA(ACUAL, ARREGLO);
    INTEGER ACUAL;
    EBCDIC ARRAY ARREGLO[0];
    BEGIN
      
    DEBUGER("RESPUESTA " C ACUAL FOR * DIGITS);
    CASE ACUAL OF BEGIN
    (3):BEGIN
        WAITANDRESET(EVENT3_OUT);
        REPLACE ARREGLO[0]
             BY ARREGLO3 FOR MIN(SIZE(ARREGLO3),SIZE(ARREGLO));
        END;
    (2):BEGIN
        WAITANDRESET(EVENT2_OUT);
        REPLACE ARREGLO[0]
             BY ARREGLO2 FOR MIN(SIZE(ARREGLO2),SIZE(ARREGLO));
        END;
    (1):BEGIN
        WAITANDRESET(EVENT1_OUT);
        REPLACE ARREGLO[0]
             BY ARREGLO1 FOR MIN(SIZE(ARREGLO1),SIZE(ARREGLO));
        END;
    ELSE:
    END OF CASE;
    DEBUGER("RESPUESTA EXIT " C ACUAL FOR * DIGITS)
    H_BUG(ARREGLO,SIZE(ARREGLO));
    END OF RESPUESTA;
      
  EXPORT RESPUESTA;
      
 %%%%%%%%%%%%%%%  OUTHER BLOCK  %%%%%%%%%%%%%%%%%%%%%
      
  DEBUGER("OUTHER BLOCK");
  PROCESS PARA(EVENT1_IN, EVENT1_OUT, ARREGLO1)[T1];
  PROCESS PARA(EVENT2_IN, EVENT2_OUT, ARREGLO2)[T2];
  PROCESS PARA(EVENT3_IN, EVENT3_OUT, ARREGLO3)[T3];
  WAIT((10));   %Para dejar que arranquen (deberia preguntar por STATUS)
      
  FREEZE(TEMPORARY);
      
  T1.TASKVALUE := 99;
  CAUSE(EVENT1_IN);
  T2.TASKVALUE := 99;
  CAUSE(EVENT2_IN);
  T3.TASKVALUE := 99;
  CAUSE(EVENT3_IN);
  I := 3;
  WHILE (T1.STATUS NEQ VALUE(TERMINATED)) DO
    BEGIN
    WAIT((20));
    IF I :=* - 1 <= 0 THEN T1.STATUS := VALUE(TERMINATED);
    END;
  I := 3;
  WHILE (T2.STATUS NEQ VALUE(TERMINATED)) DO
    BEGIN
    WAIT((20));
    IF I :=* - 1 <= 0 THEN T2.STATUS := VALUE(TERMINATED);
    END;
  I := 3;
  WHILE (T3.STATUS NEQ VALUE(TERMINATED)) DO
    BEGIN
    WAIT((20));
    IF I :=* - 1 <= 0 THEN T3.STATUS := VALUE(TERMINATED);
    END;
END.
