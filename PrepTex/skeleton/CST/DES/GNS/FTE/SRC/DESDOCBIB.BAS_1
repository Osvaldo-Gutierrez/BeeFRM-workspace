100
	COMMON ( FIO_VARI ) STRING FILLER=26,FIO_STAT=1,FIO_INFO=1,	&
				   FIO_ACCS=1,FILL
	%INCLUDE %FROM %CDD "DESREG.ENT"
	COMMON ( ENT ) ENT ENT
	%INCLUDE %FROM %CDD "DESREG.REL"
	COMMON ( REL ) REL REL
	DECLARE STRING	CONSTANT	FIO_STAT_OKS = "0",	&
					FIO_ACCS_UPD = "3"

	DECLARE INTEGER NUMTOKEN,	SC_NUMTOKEN	,&
			SZTOKEN	, 	SC_SZTOKEN	,&
			TOKEN	,	SC_TOKEN 	,&
			P_P	,	SC_P_P		,&
			P_Q	,	SC_P_Q 		,&
			SZ_I_B

	DECLARE	STRING	C_Q	,	SC_C_Q		,&
			VALTOKEN,	SC_VALTOKEN	,&
			STRTOKEN,	GLS_CHAR

	DECLARE INTEGER	CONSTANT &
			KEYTOK = 1,	IDNTOK = 2	,&
			NUMTOK = 3,	STRTOK = 4	,&
			CHRTOK = 5,	EOLTOK = 6	,&
			ETXTOK = 7,	HTAB   = 9


	DECLARE INTEGER C_FILE_BIB,	ACCION		,&
			T_ENTI,		S_ENTI		,&
			T_REG

	DECLARE STRING  &
			ASCI_BELL,	FILE_BIB	,&
			O_L,		V_M(4)		,&
			PROY,		C_BIBL		,&
			E_MODU,		V_MODU(50)	,&
			S_SECC,		V_SECC(50)	,&
			E_TENT,		V_TENT(50)	,&
			E_BIBL,		V_BIBL(50)	,&
			E_BIB1,		E_SECC		,&
			E_PROG,		C_TENT		,&
			E_MOV1,		T_PRO


   DECLARE INTEGER CONSTANT &
			HTAB 	  =  9,	NO	  =  0	,&
			ZI	  =  1

   DECLARE STRING CONSTANT &
			C_IDE	= "I"			,&
			C_ENV	= "E"			,&
			C_FIL	= "F"			,&
			C_REP	= "R"			,&
			C_WOR	= "W"			,&
			C_PRO	= "P"			,&
			C_INP	= "I"			,&
			C_OUT	= "O"			,&
			C_UPD	= "U"			,&
			C_LIN	= "L"
210
 !==========================================================================
    DEF INTEGER NEXTTOKEN
	ON ERROR GO TO LABE_ERRO
	IF TOKEN = ETXTOK THEN
		NEXTTOKEN = ETXTOK
		GO TO LABE_ASIG
	END IF
        P_P = P_Q 
 LABE_SIGA:
	WHILE (MID$(I_B$,P_P,1) = " " OR ASCII(MID$(I_B$,P_P,1)) = HTAB) AND &
			P_P <= SZ_I_B
		P_P = P_P + 1
	NEXT
	P_Q = P_P 
 NEXT_READ:
	IF P_P > SZ_I_B OR I_B$ = "" THEN
		GET #C_FILE_BIB%
		SZ_I_B = RECOUNT
	     	MOVE FROM #C_FILE_BIB% , I_B$ = SZ_I_B
		P_P, P_Q  = 1
		GO TO LABE_SIGA
	END IF
	C_Q = MID$(I_B$,P_Q,1)
	IF (C_Q >= "A" AND C_Q <= "Z") OR (C_Q >= "a" AND C_Q <= "z") THEN
		 GLS_CHAR = MID$(I_B$,P_P,1)
	         WHILE ( ( GLS_CHAR >= "A" AND GLS_CHAR <= "Z" ) OR &
			 ( GLS_CHAR >= "a" AND GLS_CHAR <= "z" ) OR &
			 ( GLS_CHAR >= "0" AND GLS_CHAR <= "9" ) OR &
			   GLS_CHAR  = "-" )
				P_P = P_P + 1
				GLS_CHAR = MID$(I_B$,P_P,1)
		 NEXT
	         SZTOKEN = P_P - P_Q
		 NEXTTOKEN = IDNTOK
	   	 VALTOKEN = MID$(I_B$,P_Q,SZTOKEN)
	ELSE
	IF C_Q >= "0" AND C_Q <= "9" THEN
	          WHILE MID$(I_B$,P_P,1) >= "0" AND MID$(I_B$,P_P,1) <= "9"
		             P_P = P_P + 1
	          NEXT
	          SZTOKEN = P_P - P_Q
		  NEXTTOKEN = NUMTOK
		  VALTOKEN = MID$(I_B$,P_Q,SZTOKEN)
	          NUMTOKEN  = VAL(VALTOKEN)
	ELSE
	IF C_Q = '"'  OR C_Q = "'" THEN
		P_P = P_P + 1
	        WHILE MID$(I_B$,P_P,1) <> C_Q AND P_P <= SZ_I_B
  	              P_P = P_P + 1
	        NEXT
	        SZTOKEN = P_P - (P_Q + 1)
	        P_P = P_P + 1
		NEXTTOKEN = STRTOK
		STRTOKEN = MID$(I_B$,P_Q + 1,SZTOKEN)
		VALTOKEN = C_Q + STRTOKEN + C_Q
	ELSE
		NEXTTOKEN = CHRTOK
		VALTOKEN = MID$(I_B$,P_P,1)
		P_P = P_P + 1
		SZTOKEN = 1
	END IF
	END IF
	END IF
	GO TO LABE_ASIG
 LABE_ERRO:
	CLOSE #C_FILE_BIB%
	IF ERR = 11 THEN
		NEXTTOKEN = ETXTOK
	ELSE
		PRINT "ERROR(";ERR;") ";ERT$(ERR);" en linea ";erl;&
		      ", Modulo ";ern$
	END IF
	RESUME 800
 LABE_ASIG:
	P_Q = P_P
800
	END DEF

 !==========================================================================
   DEF INTEGER PROXTOKEN
	TOKEN = NEXTTOKEN
	IF TOKEN = IDNTOK THEN
		 SELECT VALTOKEN
			CASE "IDENTIFICATION"
				TOKEN = NEXTTOKEN
				IF VALTOKEN = "DIVISION" THEN
					S_SECC = C_IDE
				END IF
			CASE "ENVIRONMENT"
				TOKEN = NEXTTOKEN
				IF VALTOKEN = "DIVISION" THEN
					S_SECC = C_ENV
				END IF
			CASE "FILE"
				TOKEN = NEXTTOKEN
				IF VALTOKEN = "SECTION" THEN
					S_SECC = C_FIL
				END IF
			CASE "REPORT"
				TOKEN = NEXTTOKEN
				IF VALTOKEN = "SECTION" THEN
					S_SECC = C_REP
				END IF
			CASE "LINKAGE"
				TOKEN = NEXTTOKEN
				IF VALTOKEN = "SECTION" THEN
					S_SECC = C_LIN
				END IF
			CASE "PROCEDURE"
				TOKEN = NEXTTOKEN
				IF VALTOKEN = "DIVISION" THEN
					S_SECC = C_PRO
				END IF
			CASE "WORKING-STORAGE"
				TOKEN = NEXTTOKEN
				IF VALTOKEN = "SECTION" THEN
					S_SECC = C_WOR
				END IF
			CASE ELSE
		END SELECT
	END IF
	PROXTOKEN = TOKEN
   END DEF

 !==========================================================================

   DEF INTEGER PROC_ENTI
	E_MODU = E_MODU + SPACE$(12-LEN(E_MODU))
	E_BIBL = E_BIBL + SPACE$(12-LEN(E_BIBL))
	S_ENTI = NO
	FOR I% = 1 TO T_ENTI
		IF E_TENT = V_TENT(I%) AND E_MODU = V_MODU(I%) AND &
		   E_BIBL = V_BIBL(I%) THEN
			S_ENTI = ZI
		END IF
	NEXT I%
	IF S_ENTI = NO THEN
		T_ENTI = T_ENTI + 1
		V_TENT(T_ENTI) = E_TENT
		V_MODU(T_ENTI) = E_MODU
		V_BIBL(T_ENTI) = E_BIBL
		V_SECC(T_ENTI) = E_SECC
	END IF	

   END DEF


 !==========================================================================

   DEF INTEGER PROC_CALL
	TOKEN = PROXTOKEN
	IF TOKEN = STRTOK THEN
		E_TENT = "P"
		E_MODU = STRTOKEN
		E_BIBL = SPACE$(6)
		E_SECC = SPACE$(1)
		IF MID$(E_MODU,4,1) <> "$" THEN
			ACCION = PROC_ENTI
		END IF
		IF MID$(E_MODU,4,3) = "FIO" THEN
			E_TENT = "A"
			E_MODU = MID$(E_MODU,1,3) + MID$(E_MODU,7,3)
			E_BIBL = SPACE$(6)
			TOKEN = NEXTTOKEN
			TOKEN = NEXTTOKEN
			IF VALTOKEN = "BY" THEN
				TOKEN = NEXTTOKEN
				TOKEN = NEXTTOKEN
			END IF
			M_OPEN$ = STRTOKEN
			I_I% = INSTR(1,M_OPEN$,"<")
			I_D% = INSTR(1,M_OPEN$,">")
			IF I_I% <> 0 AND I_D% <> 0 THEN
				I_D% = I_D% - ( I_I% + 1)
				M_OPEN$ = MID$(M_OPEN$,I_I% + 1,I_D%)
				IF M_OPEN$ = 'OPEN_INPUT'  OR &
				   M_OPEN$ = 'OPEN_INP'    OR &
				   M_OPEN$ = 'OPEN_INPUT'  OR &
				   M_OPEN$ = 'OPEN_INP'    OR &
				   M_OPEN$ = 'OPEN_I'      OR &
				   M_OPEN$ = 'INP'         THEN
					E_SECC = "I"
					ACCION = PROC_ENTI
				   ELSE
				IF M_OPEN$ = 'OPEN_OUTPUT' OR &
				   M_OPEN$ = 'OPEN_OUT'    OR &
				   M_OPEN$ = 'OPEN_O'      OR &
				   M_OPEN$ = 'OUT'	   THEN
					E_SECC = "O"
					ACCION = PROC_ENTI
				   ELSE
				IF M_OPEN$ = 'OPEN_UPDATE' OR &
				   M_OPEN$ = 'OPEN_UPD'    OR &
				   M_OPEN$ = 'OPEN_U'      OR &
				   M_OPEN$ = 'UPD'         THEN
					E_SECC = "U"
					ACCION = PROC_ENTI
				   ELSE
				IF M_OPEN$ = 'OPEN_EXTEND' OR &
				   M_OPEN$ = 'OPEN_EXT'    OR &
				   M_OPEN$ = 'OPEN_E'      OR &
				   M_OPEN$ = 'EXT'	   THEN
					E_SECC = "E"
					ACCION = PROC_ENTI
				END IF
				END IF
				END IF
				END IF
			END IF
		END IF
 !!!	ELSE
 !!!		E_MODU = "RUTINA VARIABLE " + VALTOKEN
 !!!		ACCION = PROC_ENTI
	END IF
   END DEF


 !==================================================================

   DEF INTEGER PROC_COPY
	TOKEN = PROXTOKEN
	IF TOKEN = STRTOK THEN
		E_MODU = STRTOKEN
	ELSE
		E_MODU = VALTOKEN
	END IF
	TOKEN = NEXTTOKEN
	IF VALTOKEN = "FROM" THEN
		E_TENT = "R"
		E_BIBL = MID$(E_MODU,1,INSTR(1,E_MODU,".")-1)
		E_MODU = MID$(E_MODU,INSTR(1,E_MODU,".")+1,	&
			 LEN(E_MODU)-INSTR(1,E_MODU,"."))
		E_SECC = SPACE$(1)
	ELSE
		TOKEN = NEXTTOKEN
		E_TENT = "M"
		E_MODU = E_MODU
		IF TOKEN = STRTOK THEN
			E_BIBL = STRTOKEN
		ELSE
			E_BIBL = VALTOKEN
		END IF
		E_SECC = S_SECC
 	END IF
	ACCION = PROC_ENTI
   END DEF

 !==================================================================

   DEF INTEGER PROC_MOVE
	TOKEN = NEXTTOKEN
	IF TOKEN = STRTOK THEN
		E_MOV1 = STRTOKEN
	ELSE
		GO TO FIN_MOVE
	END IF
	TOKEN = NEXTTOKEN
	IF VALTOKEN <> "TO" THEN
		GO TO FIN_MOVE
	END IF
	TOKEN = NEXTTOKEN
	IF VALTOKEN = "FRM-NLIB" THEN
		E_BIBL = E_MOV1
	ELSE
	IF VALTOKEN = "FRM-NAME" THEN
		E_MODU = E_MOV1
	ELSE
		GO TO FIN_MOVE
	END IF
	END IF
	TOKEN = NEXTTOKEN
	IF VALTOKEN = "." THEN
		TOKEN = NEXTTOKEN
	END IF
	IF VALTOKEN <> "MOVE" THEN
		GO TO FIN_MOVE
	END IF
	TOKEN = NEXTTOKEN
	IF TOKEN = STRTOK THEN
		E_MOV1 = STRTOKEN
	ELSE
		GO TO FIN_MOVE
	END IF
	TOKEN = NEXTTOKEN
	IF VALTOKEN <> "TO" THEN
		GO TO FIN_MOVE
	END IF
	TOKEN = NEXTTOKEN
	IF VALTOKEN = "FRM-NLIB" THEN
		E_BIBL = E_MOV1
	ELSE
	IF VALTOKEN = "FRM-NAME" THEN
		E_MODU = E_MOV1
	ELSE
		GO TO FIN_MOVE
	END IF
	END IF
	E_TENT = "F"
	E_SECC = SPACE$(1)
	ACCION = PROC_ENTI
 FIN_MOVE:
   END DEF

 !==================================================================




 ! ------------------------------------------------------------------
 !               MODULO PRINCIPAL
 ! __________________________________________________________________


	ON ERROR GO TO  LABE_BADD
	ASCI_BELL = CHR$(07)
	O_L = CHR$(13) + CHR$(10)
	C_TENT = "M"
	E_SECC = " "
	E_BIB1 = SPACE$(6)
	C_FILE_BIB% = 1	
	V_M(1) = ""
	V_M(2) = "	"
	V_M(3) = "		"
	V_M(4) = "			"
	BLANCO$ = ""

	CALL LIB$GET_SYMBOL("PTH",FILE_BIB)
	CALL LIB$GET_SYMBOL("MOD",E_PROG)
	CALL LIB$GET_SYMBOL("BIB",C_BIBL)
	CALL LIB$GET_SYMBOL("DES$PRY",PROY)

	OPEN FILE_BIB FOR INPUT  AS FILE #C_FILE_BIB%,	RECORDSIZE 255, &
	             ORGANIZATION SEQUENTIAL VARIABLE, 	RECORDTYPE ANY

	GET #C_FILE_BIB%
	SZ_I_B  = RECOUNT
	MOVE FROM #C_FILE_BIB% , I_B$ = SZ_I_B
	P_P,P_Q = 1
	J% = INSTR(1,I_B$," ") + 1
	IF J% = 1 THEN
		J% = INSTR(1,I_B$,"	") + 1
	END IF
	SW% = 0
	WHILE ( J% <= SZ_I_B ) AND ( SW% = 0 )
		IF ( MID$(I_B$,J%,1) <> " " )       AND	&
		   ( MID$(I_B$,J%,1) <> "	" ) THEN
			SW% = 1
		ELSE
			J% = J% + 1
		END IF
	NEXT
	ENT::ENT_GLS_DESC = MID$(I_B$,J%,SZ_I_B - J% + 1)
	WHILE TOKEN <> ETXTOK
		IF VALTOKEN = "CALL" THEN
			ACCION = PROC_CALL
		ELSE
		IF VALTOKEN = "COPY" THEN
			ACCION = PROC_COPY
		ELSE
		IF VALTOKEN = "MOVE" THEN
			ACCION = PROC_MOVE
		END IF
		END IF
		END IF
		TOKEN = PROXTOKEN
	NEXT
	FIO_ACCS = FIO_ACCS_UPD
	CALL "DESFIOENT" BY REF ("<ACC>")
	CALL "DESFIOENT" BY REF ("<UPD>")
	FIO_ACCS = FIO_ACCS_UPD
	CALL "DESFIOREL" BY REF ("<ACC>")
	CALL "DESFIOREL" BY REF ("<UPD>")
	ENT::ENT_KEY_TENT = C_TENT
	ENT::ENT_KEY_MODU = E_PROG
	ENT::ENT_KEY_BIBL = C_BIBL
	ENT::ENT_GLS_TPRO = T_PRO
	CALL "DESFIOENT" BY REF ("<PUT>")
	IF FIO_STAT <>  FIO_STAT_OKS THEN
		CALL "DESFIOENT" BY REF ("<MOD>")
	END IF		
	FOR I% = 1 TO T_ENTI
		IF V_BIBL(I%) = "TXT" OR &
		   V_BIBL(I%) = "GEN" OR &
		   V_BIBL(I%) = "REG" OR &
		   V_BIBL(I%) = "FMS" THEN
			V_BIBL(I%) = PROY + V_BIBL(I%) 
		END IF
		REL::REL_KEY_TEN1 = V_TENT(I%)
		REL::REL_KEY_MOD1 = V_MODU(I%)
		REL::REL_KEY_BIB1 = V_BIBL(I%)
		REL::REL_KEY_TEN2 = C_TENT
		REL::REL_KEY_MOD2 = E_PROG
		REL::REL_KEY_BIB2 = C_BIBL
		REL::REL_GLS_MODO = V_SECC(I%)
		REL::REL_GLS_DISP = "   "
		CALL "DESFIOREL" BY REF ("<PUT>")		
		IF FIO_STAT <>  FIO_STAT_OKS THEN
			CALL "DESFIOREL" BY REF ("<MOD>")
		END IF		
 !!!	PRINT V_TENT(I%);"  *  ";V_MODU(I%);"  *  ";V_BIBL(I%);"  *  ";C_TENT;"  *  "; &
 !!!		E_PROG;"  *  ";E_BIB1;"  *  ";V_SECC(I%)
	NEXT I%
	GO TO LABE_ATRA
		
 LABE_BADD:
	PRINT "ERROR(";ERR;") : ";ERT$(ERR);" en linea ";erl;", Modulo ";ern$
	RESUME 999
999
	CALL SYS$EXIT BY VALUE (0)
 LABE_ATRA:
 END
