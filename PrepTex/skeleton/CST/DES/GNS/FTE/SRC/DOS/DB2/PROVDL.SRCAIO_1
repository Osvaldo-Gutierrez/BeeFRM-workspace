100
 !!! 
	COMMON ( FIO_VARI ) STRING FILLER=26,FIO_STAT=1,FIO_INFO=1,	&
				   FIO_ACCS=1,FILL
        RECORD DMN
               STRING  DMN_COD_DOMI=32
               STRING  DMN_COD_SIST=03
               STRING  DMN_COD_REGI=03
               STRING  DMN_COD_TABL=04
               STRING  DMN_COD_TIPO=01
               STRING  DMN_MSC_FMTO=01
               STRING  DMN_NUM_LARG=03
               STRING  DMN_GLS_FIMP=20
               STRING  DMN_GLS_VALI=16
               STRING  DMN_GLS_BUSQ=16
               STRING  DMN_GLS_DISP=59
	END RECORD DMN
	COMMON ( DMN ) DMN DMN
	RECORD	RCR
               STRING  RCR_COD_RECO=32
               STRING  RCR_COD_DOMI=32
               STRING  RCR_COD_SIST=03
               STRING  RCR_COD_REGI=03
               STRING  RCR_GLS_FIMP=20
               STRING  RCR_GLS_DISP=68
	END RECORD RCR
	COMMON ( RCR ) RCR RCR
   DECLARE INTEGER                      			 &
	NUMTOKEN           					,&
	SZTOKEN            					,&
	TOKEN              					,&
	P_P                					,&
	P_Q                					,&
	SZ_I_B

   DECLARE   STRING						 &
	C_Q                					,&
	VALTOKEN           					,&
	STRTOKEN

   DECLARE INTEGER   CONSTANT					 &
	KEYTOK = 1,         		IDNTOK = 2		,&
	NUMTOK = 3,         		STRTOK = 4		,&
	CHRTOK = 5,         		EOLTOK = 6		,&
	ETXTOK = 7,         		HTAB   = 9

200
   DECLARE INTEGER						 &
	MAP_CNL_FDMN,			MAP_CNL_FRCR		,&
	MAP_CNL_FBMS,			MAP_TOT_CMPO		,&
	MAP_CNL_FGEN,			MAP_TOT_CIDX		,&
	MAP_CNL_FTXT,			MAP_TOT_FILE		,&
	MAP_CNL_FCRT,			MAP_NUM_PICT		,&
	MAP_SWI_FILE,        		MAP_NUM_LINE        	,&
	MAP_SWI_PFLD,			MAP_NUM_COLU		,&
	MAP_SWI_FECH,			MAP_NUM_CORR		,&
	MAP_SWI_VERF,			MAP_NUM_TTEX		,&
	MAP_SWI_CFRM,			MAP_NUM_INFE        	,&
	MAP_SWI_GLOS,			MAP_NUM_SUPE		,&
	MAP_SWI_ERRO,			MAP_IND_OVER		,&
	MAP_IND_CMPO						,&
	WBMS_NUM_SOR						,&
	WTXT_NUM_SOR,       		MAP_IND_NUM		,&
	MAP_VEC_UNDE(10)					,&
	MAP_VEC_FICO(150,2),		MAP_MAT_SCRN(24,80) 	,&
	MAP_VEC_TFLD(150)					,&
	MAP_VEC_DSPL(150),		MAP_VEC_DERI(150)	,&
	MAP_VEC_PFLD(150),  		MAP_VEC_MOVE(150)  	,&
	MAP_VEC_SCLR(150), 		MAP_VEC_LGLS(150)	,&
	OVR_NUM_COL,        		MAP_NUM_VSZ        ,&
	OVR_NUM_FIL,        MAP_NUM_ASC        ,&
	MAP_NUM_BAS			        ,&
	BMS_NUM_DPZ,        BMS_NUM_PIC        ,&
	ANT_INDEX,          NIV_INDEX          ,&
	TMP_INDEX,          MAP_VEC_PROT(150)  ,&
	ACT_INDEX,          MAP_VEC_TIDX(150)        ,&
	MAP_VEC_VALI(150),   MAP_VEC_PKEY(150)  ,&
	MAP_NUM_NCS,        MAP_NUM_NCI        ,&
	MAP_VEC_NUME(150)                       ,&
	MAP_NUM_TFEC,       OVR_NUM_LEN        ,&
	OVR_NUM_ADI,        MAP_VEC_ENT(150)   ,&
	MAP_VEC_DECM(150),   MAP_VEC_BYA(150)  ,&
	MAP_VEC_VAUT(150),  MAP_VEC_GLOS(150)  ,&
	MAP_VEC_FECH(150),	MAP_TOT_NOMB   ,&
	MAP_TOT_REPE	,	MAP_VEC_IOV(150),&
	MAP_VEC_BUS(150),	MAP_IND_TFLD	,&
	MAP_VEC_TVAL(150),	FIO_TOT_FLD	,&
	FIO_TOT_LEN,		FIO_TOT_KCO(25) ,&
	FIO_VEC_TDCK(25),	FIO_VEC_TSDC(60,15),&
	FIO_VEC_TOCK(25),	FIO_VEC_TSOC(60,15),&
	MSG_IDX_MENS,		FIO_LINE

   DECLARE   STRING                           &
      MAP_ASC_BEL,        MAP_ASC_NWL        ,&
      MAP_FIL_BMS,        MAP_FIL_TXT        ,&
      MAP_FIL_HST,	  MAP_FIL_CRT	     ,&
      MAP_FIL_DMN,        MAP_FIL_RCR        ,&
      MAP_GLS_WRIT,       MAP_GLS_FLG        ,&
      WRT_GLS_LIN,        WRT_GLS_COL        ,&
      WRT_GLS_COR,        MAP_GLS_PIC        ,&
      WRT_GLS_DAT,        MAP_GLS_DEF        ,&
      MAP_GLS_MAPA,       MAP_GLS_PROY       ,&
      MAP_GLS_PBM,        MAP_GLS_TYP        ,&
      MAP_GLS_L11,        MAP_GLS_L12        ,&
      MAP_GLS_L13,        MAP_GLS_CMP        ,&
      MAP_GLS_L21,        MAP_GLS_L31        ,&
      MAP_GLS_FIL,        MAP_VEC_OBLI(150)   ,&
      MAP_GLS_COL,        MAP_GLS_VIX(150)   ,&
      MAP_GLS_POS,        MAP_GLS_BMS        ,&
      MAP_GLS_TXT,        MAP_GLS_PXZ        ,&
      MAP_GLS_STP,        MAP_FIL_GEN        ,&
      MAP_VEC_CMP(150),   MAP_VEC_REGI(150)   ,&
      MAP_VEC_TIPO(150),   MAP_VEC_NOMB(150)   ,&
      V_ANSI(6),          MAP_FIL_PT1        ,&
      MAP_FIL_EDT        ,&
      MAP_VEC_FIL(50),    MAP_GLS_HLP        ,&
      MAP_GLS_DFL,        MAP_GLS_MST        ,&
      MAP_VEC_BLK(10)    			,&
      MAP_VEC_NRTN(150),   MAP_GLS_RED        ,&
      MAP_GLS_VFEC(4),    MAP_GLS_VRF(6)     ,&
      SGN_LEAD,           MAP_VEC_TAB(150)   ,&
      MAP_VEC_DMSA(5),    MAP_GLS_PRE        ,&
      MAP_GLS_SFEC,       MAP_GLS_DLD        ,&
      MAP_GLS_DLI,        MAP_GLS_IDC(2)     ,&
      MAP_GLS_NOMB,        MAP_GLS_OCC        ,&
      MAP_GLS_MAT,	  MAP_GLS_EDTN	     ,&
      MAP_GLS_NIV_FLD,    MAP_GLS_SPA_FLD    ,&
      MAP_GLS_NIV_FEC,    MAP_GLS_SPA_FEC    ,&
      MAP_GLS_NIV_VRF,    MAP_GLS_SPA_VRF    ,&
      MAP_GLS_NIV_IDC,    MAP_GLS_SPA_IDC    ,&
      MAP_SEPA_PIC,       MAP_SEPA_LEN       ,&
      MAP_SEPA_ATR,       GEN_GLS_PRT        ,&
      MAP_VEC_NMR(150),   GEN_GLS_VAL        ,&
      MAP_GLS_PIC_ALF,    MAP_GLS_PIC_EDT    ,&
      MAP_VEC_ISG(150),	  MAP_GLS_DARK	     ,&
      FIO_CMND				     ,&
      MAP_GLS_VCOD,       MAP_GLS_VIND       ,&
      MAP_GLS_GCOD,       MAP_GLS_GIND       ,&
      MAP_GLS_IDEN,	  MAP_VEC_REPE(300)  ,&
      MAP_GLS_SECC,	  MAP_GLS_IZR	     ,&
      FIO_VEC_FLD(250),	  FIO_VEC_ERR(50)    ,&
      FIO_VEC_LEN(250),	  FIO_VEC_TYP(250)   ,&
      FIO_VEC_PIC(250)			     ,&
      FIO_VEC_DSP(80),	  FIO_TBL	     ,&
      FIO_REG,		  FIO_PRF	     ,&
      FIO_HST					,&
      WSS_VEC_KEY_NODUP(100)                    ,&
      FIO_VEC_KEY(25,20), FIO_VEC_KEY_ID(20,20) ,&
      FIO_VEC_KEY_OCUR(20,20), ID_CUR           ,&
      FIO_VEC_KEY_DCUR(20,20), FIO_GLS_PIC	,&
      FIO_VEC_STR_DCUR(10,10,60),	STR_CUR,&
      FIO_VEC_STR_OCUR(10,10,60),	GEN_CUR,&
      FIO_VEC_DUP(20)

   DECLARE   STRING CONSTANT			&
      FIO_STAT_OKS  = "0"		      ,&
      BOLD_I = "[5m[1m"		      ,&
      BOLD_D = "[0m"

   DECLARE STRING POS_VEC_ZRS(4)
      POS_VEC_ZRS(1) = "0"
      POS_VEC_ZRS(2) = ""
      POS_VEC_ZRS(3) = ""
      POS_VEC_ZRS(4) = ""

   DECLARE STRING MAP_GLS_BYA(4)
      MAP_GLS_BYA(1) = "FRM-CPIM-AEY"
      MAP_GLS_BYA(2) = "FRM-CPIM-UBY"
      MAP_GLS_BYA(3) = "FRM-CPIM-ANY"
      MAP_GLS_BYA(4) = "FRM-CPIM-UNY"

   DECLARE STRING MAP_VEC_FFEC(7)
      MAP_VEC_FFEC(1) = " 'ddmmssaa' "
      MAP_VEC_FFEC(2) = " 'ddmmaa' "
      MAP_VEC_FFEC(3) = " 'mmssaa' "
      MAP_VEC_FFEC(4) = " 'mmaa' "
      MAP_VEC_FFEC(5) = " 'ssaa' "
      MAP_VEC_FFEC(6) = " 'ddmm' "
      MAP_VEC_FFEC(7) = " 'aa' "

   DECLARE STRING MAP_VEC_VFEC(7)
      MAP_VEC_VFEC(1) = "FEC"
      MAP_VEC_VFEC(2) = "DMA"
      MAP_VEC_VFEC(3) = "MSA"
      MAP_VEC_VFEC(4) = "FMA"
      MAP_VEC_VFEC(5) = "FSA"
      MAP_VEC_VFEC(6) = "FDM"
      MAP_VEC_VFEC(7) = "FFA"

   DECLARE INTEGER   CONSTANT                 &
      MAP_CTE_YES =  1,   MAP_CTE_NOT =  0   ,&
      MAP_ASC_LFD = 10,   MAP_ASC_CRT = 13   ,&
      MAP_CTE_NUM =  0,   MAP_CTE_ALF =  1   ,&
      MAP_CTE_IDF =  2,   MAP_IND_FLD =  0   ,&
      MAP_IND_IKY =  1,   MAP_IND_MKY =  2   ,&
      MAP_IND_AKY =  3                       ,&
      MAP_IND_FIC =  4 				,&
      MG_C       =  1,   MG_A       =  2     ,&
      MG_B       =  3,   MG_1       =  4     ,&
      MG_2       =  5,   MG_N       =  6     ,&
      MAP_NUM_CODI  = 1, MAP_NUM_MISC = 2    ,&
      FEC_IND_FFEC  = 1, FEC_IND_FDMA = 2    ,&
      FEC_IND_FMSA  = 3, FEC_IND_FFMA = 4    ,&
      FEC_IND_FFSA  = 5, FEC_IND_FFDM = 6    ,&
      FEC_IND_FFFA  = 7, MAP_IND_IDC = 1     ,&
      MAP_IND_VIND  = 1, MAP_IND_VGLS = 2	,&
      MAP_IND_VVRF  = 3

	FEC$	= "FALSE"
	NRO$	= "FALSE"
	VRF$	= "FALSE"
	IDC$	= "FALSE"
	BUSTAB$	= "FALSE"
	VALCOD$	= "FALSE"
	BUSMSC$	= "FALSE"
	VALIND$ = "FALSE"
	BUSOFI$ = "FALSE"
	VALOFI$ = "FALSE"
	BUSUSR$ = "FALSE"
	VALUSR$ = "FALSE"
	VALTDU$ = "FALSE"
	ERRGLS$	= "FALSE"
 DEF INTEGER FIO_FNC_READ
 COMMENT:
	FIO_LINE = FIO_LINE + 1
	GET #MAP_CNL_FTXT
	SZ_I_B = RECOUNT
	MOVE FROM #MAP_CNL_FTXT , I_B$ = SZ_I_B
	P_P, P_Q  = 1
	IF LEFT$(I_B$,1) = "C" THEN
		GO TO COMMENT
	END IF
 END DEF

 DEF FIO_FNC_STR_CUR
 !!! FIO_VEC_TSDC(X,Y) = TOTAL DE STRING POR DCURSOR
 !!! FIO_VEC_TSOC(X,Y) = TOTAL DE STRING POR OCURSOR
 !!! FIO_VEC_TDCK(X,Y) = TOTAL DE CURSOR POR LLAVE
	STR_CUR = MID$(I_B$,P_Q ,P_P - P_Q + 1)
	CALL FIOREP(STR_CUR,'"','')
	STR_CUR = EDIT$(STR_CUR,8%)
	STR_CUR = EDIT$(STR_CUR,16%)
	STR_CUR = EDIT$(STR_CUR,128%)
	IF GEN_CUR = "OCUR" THEN
    	   FIO_VEC_TSOC(FIO_TOT_KEY,FIO_TOT_TDCK) = &
	         FIO_VEC_TSOC(FIO_TOT_KEY,FIO_TOT_TDCK) + 1
           FIO_TOT_TSOC = FIO_VEC_TSOC(FIO_TOT_KEY,FIO_TOT_TDCK) 
	   FIO_VEC_STR_OCUR(FIO_TOT_KEY,FIO_TOT_TDCK,FIO_TOT_TSOC) = STR_CUR
	ELSE
    	   FIO_VEC_TSDC(FIO_TOT_KEY,FIO_TOT_TDCK) = &
	         FIO_VEC_TSDC(FIO_TOT_KEY,FIO_TOT_TDCK) + 1
           FIO_TOT_TSDC = FIO_VEC_TSDC(FIO_TOT_KEY,FIO_TOT_TDCK) 
	   FIO_VEC_STR_DCUR(FIO_TOT_KEY,FIO_TOT_TDCK,FIO_TOT_TSDC) = STR_CUR
	END IF
 END DEF

 !====================== TOKEN ==========================================
 205
    DEF INTEGER NEXTTOKEN
    ON ERROR GO TO MAP_LAB_ERR
       IF TOKEN = ETXTOK THEN
          NEXTTOKEN = ETXTOK
          GO TO NEX_LAB_ASG
       END IF
       P_P = P_Q 
 NEX_LAB_NEW:
       WHILE (MID$(I_B$,P_P,1) = " " OR ASCII(MID$(I_B$,P_P,1)) = HTAB) AND &
          P_P <= SZ_I_B
          P_P = P_P + 1
       NEXT
       P_Q = P_P 
       IF P_P > SZ_I_B OR I_B$ = "" THEN
		FIO_NUM_FNC = FIO_FNC_READ
		GO TO NEX_LAB_NEW
       END IF
        C_Q = MID$(I_B$,P_Q,1)
        IF (C_Q >= "A" AND C_Q <= "Z") OR (C_Q >= "a" AND C_Q <= "z") THEN
            WHILE (MID$(I_B$,P_P,1) >= "A" AND MID$(I_B$,P_P,1) <= "Z" &
               OR  MID$(I_B$,P_P,1)  = "-"      &
               OR (MID$(I_B$,P_P,1) >= "0" AND MID$(I_B$,P_P,1) <= "9" ) &
          OR  MID$(I_B$,P_P,1) >= "a" AND &
              MID$(I_B$,P_P,1) <= "z")
                        P_P = P_P + 1
         NEXT
         SZTOKEN = P_P - P_Q
         NEXTTOKEN = IDNTOK
         VALTOKEN = MID$(I_B$,P_Q,SZTOKEN)
      ELSE
      IF C_Q >= "0" AND C_Q <= "9" THEN
         WHILE MID$(I_B$,P_P,1) >= "0" AND MID$(I_B$,P_P,1) <= "9"
            P_P = P_P + 1
         NEXT
         SZTOKEN = P_P - P_Q
         NEXTTOKEN = NUMTOK
         VALTOKEN = MID$(I_B$,P_Q,SZTOKEN)
         NUMTOKEN  = VAL(VALTOKEN)
      ELSE
      IF C_Q = '"'  OR C_Q = "'" THEN
         P_P = P_P + 1
         P_Q = P_P
         SZTOKEN = 0
         STRTOKEN = ""
 CONT_STR:
         WHILE MID$(I_B$,P_P,1) <> C_Q AND &
               P_P <= SZ_I_B
            P_P = P_P + 1
         NEXT
         IF MID$(I_B$,P_P,1) <> C_Q THEN
             SZTOKEN = SZTOKEN + P_P - (P_Q + 1)
 !	     IF STRTOKEN <> "" THEN
 !		L_F$ = CHR$(10) 
 !	     ELSE
 !		L_F$ = ""
 !	     END IF
             STRTOKEN = STRTOKEN + MID$(I_B$,P_Q ,P_P - P_Q + 1)
             FIO_NUM_FNC = FIO_FNC_STR_CUR
             FIO_NUM_FNC = FIO_FNC_READ
             GO TO CONT_STR
         END IF
         SZTOKEN = SZTOKEN + P_P - (P_Q + 1)
         NEXTTOKEN = STRTOK
         STRTOKEN = STRTOKEN + MID$(I_B$,P_Q ,P_P - P_Q )
	 FIO_NUM_FNC = FIO_FNC_STR_CUR
         VALTOKEN = C_Q + STRTOKEN + C_Q
         P_P = P_P + 1
      ELSE
         NEXTTOKEN = CHRTOK
         VALTOKEN = MID$(I_B$,P_P,1)
       P_P = P_P + 1
       SZTOKEN = 1
      END IF
      END IF
      END IF
      GO TO NEX_LAB_ASG
 210
 MAP_LAB_ERR:
      CLOSE #MAP_CNL_FTXT
      IF ERR = 11 THEN
          NEXTTOKEN = ETXTOK
      ELSE
          PRINT   "ERROR(";ERR;") ";ERT$(ERR);" en linea ";erl;&
            ", MODULO ";ern$
          CALL SYS$EXIT BY VALUE(0)
      END IF
      RESUME 800
 NEX_LAB_ASG:
       P_R = P_Q
       P_Q = P_P
800
   END DEF

 !====================== INICIALIZACION ======================
805
   DEF INTEGER FIO_FNC_INI
    ON ERROR GO TO MAP_LAB_OPE
      FOR I% = 1 TO 20
	FIO_VEC_DUP(I%) = "TRUE"
      NEXT I%
      MAP_GLS_IDEN = DATE$(0%) + " " + TIME$(0%)
      MAP_NUM_BAS = 65
      MAP_ASC_BEL = CHR$(07)
      MAP_CNL_FTXT = 1   
      MAP_CNL_FPT1 = 2
      MAP_CNL_FEDT = 4
      MAP_CNL_FHST = 3
      MAP_CNL_FCRT = 5

      V_ANSI(MG_C) = "      "
      V_ANSI(MG_A) = "       "
      V_ANSI(MG_B) = "           "
      V_ANSI(MG_1) = "               "
      V_ANSI(MG_2) = "                   "
      V_ANSI(MG_N) = ""
      MAP_VEC_BLK(1) = "        "
      MAP_VEC_BLK(2) = "       "
      MAP_VEC_BLK(3) = "      "
      MAP_VEC_BLK(4) = "     "
      MAP_VEC_BLK(5) = "    "
      MAP_VEC_BLK(6) = "   "
      MAP_VEC_BLK(7) = "  "
      MAP_VEC_BLK(8) = " "
      MAP_VEC_BLK(9) = ""
      MAP_ASC_NWL = CHR$(MAP_ASC_CRT) + CHR$(MAP_ASC_LFD)
      P_P,P_Q = 1
806
      CALL LIB$GET_SYMBOL("GNS$PRY",MAP_GLS_PROY)
      CALL LIB$GET_SYMBOL("GNS$FIL",MAP_GLS_FLG)
      CALL LIB$GET_SYMBOL("PTH",MAP_FIL_TXT)
      MAP_GLS_HLP = ""
807
 !!!	APERTURA  ARCHIVO REGISTRO DOMINIO
	FIO_CMND = "INP                 "
	CALL "GNSFIODMN" BY REF (FIO_CMND)
   
 !!!	APERTURA  ARCHIVO REGISTRO RECORRIDO
	FIO_CMND = "INP                 "
 	CALL "GNSFIORCR" BY REF (FIO_CMND)
   
808   OPEN MAP_FIL_TXT FOR INPUT AS FILE #MAP_CNL_FTXT,RECORDTYPE ANY,   &
         ORGANIZATION SEQUENTIAL VARIABLE,   RECORDSIZE 255

 !!!	APERTURA ARCHIVO PREPTEX-1
      MAP_GLS_FIL = MAP_GLS_PROY + "BF" + MAP_GLS_FLG
      MAP_FIL_PT1 = MAP_GLS_FIL + ".PTX"
      OPEN MAP_FIL_PT1 FOR OUTPUT AS FILE #MAP_CNL_FPT1,RECORDTYPE ANY,&
         ORGANIZATION SEQUENTIAL VARIABLE,   RECORDSIZE 255
   
 !!!	APERTURA ARCHIVO EDICION
       MAP_FIL_EDT = MAP_GLS_FIL + ".EDT"
       OPEN MAP_FIL_EDT FOR OUTPUT AS FILE #MAP_CNL_FEDT,RECORDTYPE ANY,&
          ORGANIZATION SEQUENTIAL VARIABLE,   RECORDSIZE 255
   
 !!!	APERTURA ARCHIVO HOST
      MAP_FIL_HST = MAP_GLS_PROY + "WH" + MAP_GLS_FLG + ".AIO"
      OPEN MAP_FIL_HST FOR OUTPUT AS FILE #MAP_CNL_FHST,RECORDTYPE ANY,&
         ORGANIZATION SEQUENTIAL VARIABLE,   RECORDSIZE 255

 !!!	APERTURA ARCHIVO CREATE TABLE
      MAP_FIL_CRT = MAP_GLS_PROY + "DT" + MAP_GLS_FLG + ".AIO"
      OPEN MAP_FIL_CRT FOR OUTPUT AS FILE #MAP_CNL_FCRT,RECORDTYPE ANY,&
         ORGANIZATION SEQUENTIAL VARIABLE,   RECORDSIZE 255
   
      FIO_NUM_FNC = FIO_FNC_READ
      GO TO FIN_LAB_INI
 MAP_LAB_OPE:
   PRINT MAP_ASC_BEL,MAP_ASC_BEL,MAP_ASC_BEL
   PRINT   "ERROR(";ERR;") ";ERT$(ERR);" en linea ";erl;&
           ", MODULO ";ern$
   IF ERR = 2 THEN
      PRINT MAP_FIL_TXT,FILE_WSS, " : NOMBRE DE ARCHIVO ILEGAL"
   ELSE 
   IF ERR = 5 THEN
      PRINT MAP_FIL_TXT,FILE_WSS, " ARCHIVO INEXISTENTE       "
   END IF
   END IF
   CALL SYS$EXIT BY VALUE(0)
 !  RESUME 809
 FIN_LAB_INI:
809
   END DEF

 !---- INFORMA ERRORES
   DEF INTEGER FIO_ERR
        IF ERROR_DET = 1 THEN
		GO TO FIN_FIO_ERR
        END IF
	CALL LIB$SET_SYMBOL("STS_ERR","BAD")
        FIO_VEC_ERR(01) = " Nombre de campo expected"
        FIO_VEC_ERR(02) = " , o ; expected"
        FIO_VEC_ERR(03) = " Nombre de registro expected"
        FIO_VEC_ERR(04) = " Nombre de llave expected"
        FIO_VEC_ERR(05) = " Llave no definida"
        FIO_VEC_ERR(06) = " REG o FLD o KEY o CUR expected"
        FIO_VEC_ERR(07) = " NL o LE para CURSOR expected"
        FIO_VEC_ERR(08) = " string para OCUR expected"
        FIO_VEC_ERR(09) = " string para DCUR expected"
        FIO_VEC_ERR(10) = " Numero para LEN expected"
        FIO_VEC_ERR(10) = " Tipo de campo invalido"

        B$ = LEFT$(I_B$,P_R-1) + BOLD_I + VALTOKEN + BOLD_D + RIGHT$(I_B$,P_P)

	PRINT " Error en linea " ; FIO_LINE
	PRINT B$
	PRINT FIO_VEC_ERR(MSG_IDX_MENS)
	PRINT " "
 FIN_FIO_ERR:
	ERROR_DET = 1

   END DEF


 !---- REGISTRO
   DEF INTEGER FIO_FNC_REG
 !   PRINT "EN REG"
	TOKEN = NEXTTOKEN
        IF TOKEN = IDNTOK THEN
            FIO_TBL = VALTOKEN
        ELSE
            MSG_IDX_MENS = 3
            FIO_NUM_FNC = FIO_ERR
        END IF
	FIO_REG = FIO_TBL
	FIO_PRF = MAP_GLS_PROY + "-FIO-" + FIO_TBL
	FIO_HST = FIO_TBL + "HST"
 CIC_FIO_FNC_REG:
	TOKEN = NEXTTOKEN
        IF VALTOKEN = ";" THEN
             GO TO FIN_FIO_FNC_REG
	END IF

	IF VALTOKEN = "REG" THEN
   PRINT "EN REG"
		TOKEN = NEXTTOKEN
		FIO_REG = VALTOKEN
                GO TO CIC_FIO_FNC_REG
	ELSE
	IF VALTOKEN = "PRF" THEN
   PRINT "EN PRF"
		TOKEN = NEXTTOKEN
		FIO_PRF = VALTOKEN
                GO TO CIC_FIO_FNC_REG
	ELSE
	IF VALTOKEN = "HST" THEN
   PRINT "EN HST"
		TOKEN = NEXTTOKEN
		FIO_HST = VALTOKEN
                GO TO CIC_FIO_FNC_REG
	END IF
	END IF
	END IF
	TOKEN = NEXTTOKEN
 FIN_FIO_FNC_REG:
   END DEF

 !---- LARGO
   DEF INTEGER FIO_FNC_LEN
	TOKEN = NEXTTOKEN
	IF TOKEN <> NUMTOK THEN
            MSG_IDX_MENS = 10
            FIO_NUM_FNC = FIO_ERR
	END IF
	FIO_VEC_LEN(FIO_TOT_FLD) = POS_VEC_ZRS(LEN(VALTOKEN)) +  VALTOKEN
	FIO_TOT_LEN = FIO_TOT_LEN + VAL(VALTOKEN)
 !	TOKEN = NEXTTOKEN
   END DEF

 !---- TYPE
   DEF INTEGER FIO_FNC_TYP
	TOKEN = NEXTTOKEN
	IF VALTOKEN <> "X" AND VALTOKEN <> "9" THEN
            MSG_IDX_MENS = 10
            FIO_NUM_FNC = FIO_ERR
	END IF
	FIO_VEC_TYP(FIO_TOT_FLD) = VALTOKEN
 !	TOKEN = NEXTTOKEN
   END DEF

 !---- PICTURE
   DEF INTEGER FIO_FNC_PIC
	TOKEN = NEXTTOKEN
	FIO_VEC_PIC(FIO_TOT_FLD) = STRTOKEN
 !	TOKEN = NEXTTOKEN
   END DEF

 !---- CAMPOS
   DEF INTEGER FIO_FNC_FLD
 CIC_FIO_FNC_FLD:
 !   PRINT "EN FLD"
	TOKEN = NEXTTOKEN
        IF TOKEN = IDNTOK THEN
            FIO_TOT_FLD = FIO_TOT_FLD + 1
            FIO_VEC_FLD(FIO_TOT_FLD) = VALTOKEN
        ELSE
            MSG_IDX_MENS = 1
            FIO_NUM_FNC = FIO_ERR
        END IF
 CIC_FIO_FNC_FLD_1:

	TOKEN = NEXTTOKEN

        IF VALTOKEN = ";" THEN
            GO TO FIN_FIO_FNC_FLD
        ELSE
        IF VALTOKEN = "," THEN
            GO TO CIC_FIO_FNC_FLD
        ELSE
        IF VALTOKEN = "LEN" THEN
            FIO_NUM_FNC = FIO_FNC_LEN
            GO TO CIC_FIO_FNC_FLD_1
        ELSE
        IF VALTOKEN = "TYP" THEN
            FIO_NUM_FNC = FIO_FNC_TYP
            GO TO CIC_FIO_FNC_FLD_1
        ELSE
        IF VALTOKEN = "PIC" THEN
            FIO_NUM_FNC = FIO_FNC_PIC
            GO TO CIC_FIO_FNC_FLD_1
        ELSE
            MSG_IDX_MENS = 2
            FIO_NUM_FNC = FIO_ERR
        END IF
        END IF
        END IF
        END IF
        END IF
 FIN_FIO_FNC_FLD:
   END DEF


 !---- CURSOR
   DEF INTEGER FIO_FNC_CUR
 !TOTAL DE CURSOR PARA ESTA LLAVE SE INCREMENTA EN 1
	FIO_VEC_TDCK(FIO_TOT_KEY) = FIO_VEC_TDCK(FIO_TOT_KEY) + 1
	FIO_TOT_TDCK = FIO_VEC_TDCK(FIO_TOT_KEY) 
	TOKEN = NEXTTOKEN
	ID_CUR = VALTOKEN
	IF ID_CUR <> "NL" AND ID_CUR <> "LE" THEN
            MSG_IDX_MENS = 7
            FIO_NUM_FNC = FIO_ERR
	ELSE
	FIO_VEC_KEY_ID(FIO_TOT_KEY,FIO_TOT_TDCK) = VALTOKEN
	TOKEN = NEXTTOKEN
	IF VALTOKEN = "OCUR" THEN
	    GEN_CUR = "OCUR"
	     TOKEN = NEXTTOKEN
	     IF TOKEN <> STRTOK THEN
		MSG_IDX_MENS = 8
	        FIO_NUM_FNC = FIO_ERR	
	     ELSE
		FIO_VEC_KEY_OCUR(FIO_TOT_KEY,FIO_TOT_TDCK) = VALTOKEN
	     END IF
	END IF
        TOKEN = NEXTTOKEN
	IF VALTOKEN = "DCUR" THEN
  	     GEN_CUR = "DCUR"
	     TOKEN = NEXTTOKEN
	     IF TOKEN <> STRTOK THEN
		  MSG_IDX_MENS = 9
	          FIO_NUM_FNC = FIO_ERR
	     ELSE
		FIO_VEC_KEY_DCUR(FIO_TOT_KEY,FIO_TOT_TDCK) = VALTOKEN
                TOKEN = NEXTTOKEN
	     END IF
	END IF
	END IF
   END DEF

 !---- VALIDACION DE LLAVES
   DEF INTEGER FIO_FNC_VKY
 !   PRINT "EN VKY"
	I% = 1
	WHILE KEY_CMP$ <> FIO_VEC_FLD(I%) AND&
              I% <= FIO_TOT_FLD
           I% = I% + 1
	NEXT
        IF I% > FIO_TOT_FLD THEN
            MSG_IDX_MENS = 5
            FIO_NUM_FNC = FIO_ERR
	END IF
                    
   END DEF

 !---- LLAVES
   DEF INTEGER FIO_FNC_KEY
   FIO_TOT_KEY = FIO_TOT_KEY + 1
   FIO_VEC_TDCK(FIO_TOT_KEY) = 0
   FST_KEY_NODUP$ = "NO"
 CIC_FIO_FNC_KEY:
 !   PRINT "EN KEY"
	TOKEN = NEXTTOKEN
        IF VALTOKEN = "UNI" THEN
            FIO_VEC_DUP(FIO_TOT_KEY) = "FALSE"
	    TOKEN = NEXTTOKEN
	END IF
        IF TOKEN = IDNTOK THEN
            IF FST_KEY_NODUP$ = "NO" THEN
                FST_KEY_NODUP$ = "SI"
                WSS_ENC_KEY_NODUP$ = "NO"
                FOR  JJ% = 1 TO WSS_TOT_KEY_NODUP
                      IF VALTOKEN = WSS_VEC_KEY_NODUP(JJ%) THEN
                           WSS_ENC_KEY_NODUP$ = "SI"
                           JJ% = WSS_TOT_KEY_NODUP + 1
                      END IF
                NEXT JJ%
                IF WSS_ENC_KEY_NODUP$ = "NO" THEN
                      WSS_TOT_KEY_NODUP = WSS_TOT_KEY_NODUP + 1
                      WSS_VEC_KEY_NODUP(WSS_TOT_KEY_NODUP) = VALTOKEN
                END IF
            END IF
            FIO_TOT_KCO(FIO_TOT_KEY) = FIO_TOT_KCO(FIO_TOT_KEY) + 1
            FIO_VEC_KEY(FIO_TOT_KEY,FIO_TOT_KCO(FIO_TOT_KEY)) = VALTOKEN
            IF FIO_TOT_KCO(FIO_TOT_KEY) > 1 THEN
                KEY_CMP$ = FIO_VEC_KEY(FIO_TOT_KEY,FIO_TOT_KCO(FIO_TOT_KEY))
                FIO_NUM_FNC = FIO_FNC_VKY
            END IF
        ELSE
            MSG_IDX_MENS = 4
            FIO_NUM_FNC = FIO_ERR
        END IF

	TOKEN = NEXTTOKEN

 NEW_KEY:
        IF VALTOKEN = ";" THEN
            GO TO FIN_FIO_FNC_KEY
        ELSE
        IF VALTOKEN = "CUR" THEN
            FIO_NUM_FNC = FIO_FNC_CUR
            GO TO NEW_KEY
        ELSE
        IF VALTOKEN = "," THEN
            GO TO CIC_FIO_FNC_KEY
        ELSE
            MSG_IDX_MENS = 2
            FIO_NUM_FNC = FIO_ERR
        END IF
        END IF
        END IF
 FIN_FIO_FNC_KEY:
   END DEF


   DEF INTEGER FIO_FNC_WHST
	IF FIO_VEC_PIC(I%) > "" THEN
		FIO_GLS_PIC = " " + FIO_VEC_PIC(I%) + "."
	ELSE
		FIO_GLS_PIC = " PIC " + FIO_VEC_TYP(I%) +&
			          "(" + FIO_VEC_LEN(I%) + ")."
	END IF
      CALL PUT_HST(MG_B,"03  " + C$ + FIO_GLS_PIC)

	IF FIO_VEC_PIC(I%) > "" THEN
 !!!           CALL PUT_CRT(MG_N,'TYP' + STR$(I%) + ' = "' + FIO_VEC_PIC(I%) + '"' )
		DT_STR$ = FIO_VEC_PIC(I%)
	ELSE
           IF FIO_VEC_TYP(I%) = "X" THEN
 !!!	           CALL PUT_CRT(MG_N,'TYP' + STR$(I%) + ' = "CHAR"' )
		DT_STR$ = "CHAR"
           ELSE
 !!!	           CALL PUT_CRT(MG_N,'TYP' + STR$(I%) + ' = "' + FIO_VEC_TYP(I%) + '"' )
		DT_STR$ = FIO_VEC_TYP(I%)
           END IF
	END IF
	IF I% <> FIO_TOT_FLD THEN
	      CALL PUT_CRT(MG_N,FIO_VEC_FLD(I%) + ' ' + DT_STR$ + "(" + FIO_VEC_LEN(I%) + '),' )
	END IF
 !!!      CALL PUT_CRT(MG_N,'LEN' + STR$(I%) + ' = "' + FIO_VEC_LEN(I%) + '"' )
   END DEF
   DEF INTEGER FIO_FNC_WFLD

      IF PRE_FLD$ = "CL" THEN
	    CALL PUT_HST(MG_C,"* FEC = " + MAP_GLS_IDEN)
	    CALL PUT_HST(MG_C,"* TAMANO DE REGISTRO " + STR$(FIO_TOT_LEN))
	    CALL PUT_HST(MG_C,"* ==================")
	    CALL PUT_HST(MG_A,"01  " + FIO_HST + ".")
      END IF
      FOR I% = 1 TO FIO_TOT_FLD
	P% = FIO_TOT_FLD + 1 - I%
	B$ = '"' + FIO_VEC_FLD(I%) + '"'
	E$ = FIO_VEC_FLD(P%)
	C$ = FIO_VEC_FLD(I%)
        IF PRE_FLD$ = "CL" THEN
	    FIO_NUM_FNC = FIO_FNC_WHST

	    CALL FIOREP(B$,"-","_")
	    CALL FIOREP(E$,"-","_")
	END IF
	B$ = "! " + PRE_FLD$ + STR$(I%) + " = " + B$
        CALL PUT_PTX(MG_N,B$)
	D$ = "S/" + PRE_FLD$ + STR$(P%) + "/" + E$ + "/W"
        CALL PUT_EDT(MG_N,D$)
      NEXT I%
      CALL PUT_PTX(MG_N,"!")
   END DEF



 !---------------------------- MODULO PRINCIPAL --------------------------------

 !!!   ON ERROR GO TO MAP_LAB_BAD
   MAP_NUM_FNC = FIO_FNC_INI

 LABE_SCRS:
      
   TOKEN = NEXTTOKEN
   WHILE TOKEN <> ETXTOK
      IF VALTOKEN = "TBL" THEN
           FIO_FNC_FUNC = FIO_FNC_REG
      ELSE
      IF VALTOKEN = "FLD" THEN
           FIO_FNC_FUNC = FIO_FNC_FLD
      ELSE
      IF VALTOKEN = "KEY" THEN
           FIO_FNC_FUNC = FIO_FNC_KEY
      ELSE
            MSG_IDX_MENS = 6
            FIO_NUM_FNC = FIO_ERR
      END IF
      END IF
      END IF
      TOKEN = NEXTTOKEN

   NEXT
 !	FOR N% = 1 TO 250
 !	  ZZ$ = STR$(N%) + "REG 1" + CHR$(N%) + "REG 2"
 !	  CALL PUT_PTX(MG_N,ZZ$)
 !	NEXT N%
      CALL PUT_CRT(MG_N,'DROP TABLE ' + MAP_GLS_PROY + FIO_TBL )
      CALL PUT_CRT(MG_N,'COMMIT WORK;' )
      CALL PUT_CRT(MG_N,'CREATE TABLE SUC2USE.' + MAP_GLS_PROY + FIO_TBL + ' (' )
 !!!      CALL PUT_CRT(MG_N,'FEC = "' + MAP_GLS_IDEN + '"')
 !!!      CALL PUT_CRT(MG_N,'SIS = "' + MAP_GLS_PROY + '"')
 !!!      CALL PUT_CRT(MG_N,'TBL = "' + FIO_TBL + '"')
 !!!      CALL PUT_CRT(MG_N,'NFL = ' + STR$(FIO_TOT_FLD))

      CALL PUT_PTX(MG_N,'FEC = "' + MAP_GLS_IDEN + '"')
      CALL PUT_PTX(MG_N,'SIS = "' + MAP_GLS_PROY + '"')
      CALL PUT_PTX(MG_N,'TBL = "' + FIO_TBL + '"')
      CALL PUT_PTX(MG_N,'REG = "' + FIO_REG + '"')
      CALL PUT_PTX(MG_N,'PRF = "' + FIO_PRF + '"')
      CALL PUT_PTX(MG_N,'REGHST = "' + FIO_HST + '"')
      CALL PUT_PTX(MG_N,'NFL = ' + STR$(FIO_TOT_FLD))
      CALL PUT_PTX(MG_N,'NKY = ' + STR$(FIO_TOT_KEY))
      PRE_FLD$ = "FL"
 !!!      CALL PUT_PTX(MG_N,'NKY_NODUP = ' + STR$(WSS_TOT_KEY_NODUP ))
      FOR  JJ% = 1 TO WSS_TOT_KEY_NODUP
 !!!             CALL PUT_PTX(MG_N,'IKY_NODUP' + STR$(JJ%) + ' = "' + WSS_VEC_KEY_NODUP(JJ%) + '"')
      NEXT JJ%

      FIO_NUM_FNC = FIO_FNC_WFLD
      PRE_FLD$ = "CL"
      FIO_NUM_FNC = FIO_FNC_WFLD
	CALL PUT_CRT(MG_N,FIO_VEC_FLD(FIO_TOT_FLD) + ' ' + DT_STR$ + "(" + FIO_VEC_LEN(I%) + ') )' )
	CALL PUT_CRT(MG_N,'                  IN SUC2.SUC2TS;')
      CALL PUT_EDT(MG_N,"EXIT")

      FOR I% = 1 TO FIO_TOT_KEY
	IF FIO_TOT_KCO(I%) = 1 THEN
		FIO_TOT_KCO(I%) = 2
		FIO_VEC_KEY(I%,2) = FIO_VEC_KEY(I%,1)
	END IF

	B$ = "NKY" + STR$(I%) + " = " + STR$(FIO_TOT_KCO(I%)-1)
        CALL PUT_PTX(MG_N,B$)
	B$ = "FK_" + STR$(I%) + "_DUP = " + FIO_VEC_DUP(I%)
        CALL PUT_PTX(MG_N,B$)

      FOR J% = 1 TO FIO_TOT_KCO(I%)
	B$ = "FK" + STR$(I%) + "_" + STR$(J%-1) + " = " +&
	      '"' + FIO_VEC_KEY(I%,J%) + '"'
        CALL PUT_PTX(MG_N,B$)
      NEXT J%

      FOR J% = 1 TO FIO_TOT_KCO(I%)
	B$ = "CK" + STR$(I%) + "_" + STR$(J%-1) + " = " +&
	      '"' + FIO_VEC_KEY(I%,J%) + '"'
	CALL FIOREP(B$,"-","_")
        CALL PUT_PTX(MG_N,B$)
      NEXT J%
      CALL PUT_PTX(MG_N,"!")

      IF FIO_VEC_KEY_ID(I%,1) > " " THEN
	FOR K% = 1 TO FIO_VEC_TDCK(I%)
		SUF_ELM$ = "_" + FIO_VEC_KEY_ID(I%,K%) + STR$(I%) 
		SUF_CUR$ = "CURSOR" + SUF_ELM$

		B$ = SUF_CUR$ + " = TRUE"
		CALL PUT_PTX(MG_N,B$)

 !!! STRINGS DEMASIADO LARGOS
 !!!		B$ = "O" + SUF_CUR$ + ' = ' + FIO_VEC_KEY_OCUR(I%,K%)
 !!!		CALL PUT_PTX(MG_N,B$)

 		TSO$ = "TSO" + SUF_ELM$ + " = " + STR$(FIO_VEC_TSOC(I%,K%))
 		CALL PUT_PTX(MG_N,TSO$)

 		FOR L% = 1 TO FIO_VEC_TSOC(I%,K%)
			STROCUR$ = "STROCUR" + SUF_ELM$ + "_" + STR$(L%)
			STROCUR$ = STROCUR$ + ' = "' +&
					FIO_VEC_STR_OCUR(I%,K%,L%) + '"'
			CALL PUT_PTX(MG_N,STROCUR$)
		NEXT L%

 !!! STRINGS DEMASIADO LARGOS
 !!!		B$ = "D" + SUF_CUR$ + ' = ' + FIO_VEC_KEY_DCUR(I%,K%)
 !!!		CALL PUT_PTX(MG_N,B$)


		TSD$ = "TSD" + SUF_ELM$ + " = " + STR$(FIO_VEC_TSDC(I%,K%))
		CALL PUT_PTX(MG_N,TSD$)

		FOR L% = 1 TO FIO_VEC_TSDC(I%,K%)
			STRDCUR$ = "STRDCUR" + SUF_ELM$ + "_" + STR$(L%)
			STRDCUR$ = STRDCUR$ + ' = "' +&
					FIO_VEC_STR_DCUR(I%,K%,L%) + '"'
			CALL PUT_PTX(MG_N,STRDCUR$)
		NEXT L%
	NEXT K%
      END IF
	NEXT I%

        CALL PUT_PTX(MG_N,"INCLUDE 'GNSSRCAIO:GNSBFREG.SRCAIO'")
 !!!        CALL PUT_CRT(MG_N,"INCLUDE 'GNSSRCAIO:GNSCRTBL.SRCAIO'")
 GO TO LABE_ATRA

   
 MAP_LAB_BAD:
   PRINT MAP_ASC_BEL,MAP_ASC_BEL
   PRINT "Error(";ERR;") ";ERT$(ERR);" en linea ";erl; ", Modulo ";ern$
   IF ERR = 2 THEN
      PRINT MAP_FIL_TXT,FILE_WSS, " : Nombre de archivo ilegal"
   ELSE 
   IF ERR = 5 THEN
      PRINT MAP_FIL_TXT,FILE_WSS, " Archivo inexistente       "
   ELSE
   IF ERR = 55 THEN
      PRINT " Indice fuera de rango "
   END IF
   END IF
   END IF
   RESUME 999
999
 LABE_ATRA:
 END
1600   SUB PUT_PTX(INTEGER MARGEN, STRING REGISTRO BY DESC)
      DECLARE STRING REG_GEN   , V_ANSI(6)
      DECLARE INTEGER   CONSTANT          &
         MG_C       =  1,   MG_A       =  2,&
         MG_B       =  3,   MG_1       =  4,&
         MG_2       =  5,   MG_N       =  6
      V_ANSI(MG_C) = "      "
      V_ANSI(MG_A) = "       "
      V_ANSI(MG_B) = "           "
      V_ANSI(MG_1) = "                "
      V_ANSI(MG_2) = "                   "
      V_ANSI(MG_N) = ""
      REG_GEN = V_ANSI(MARGEN) + REGISTRO
      PRINT #2,"*% " + REG_GEN
   END SUB
1610   SUB PUT_EDT(INTEGER MARGEN, STRING REGISTRO BY DESC)
      DECLARE STRING REG_GEN   , V_ANSI(6)
      DECLARE INTEGER   CONSTANT          &
         MG_C       =  1,   MG_A       =  2,&
         MG_B       =  3,   MG_1       =  4,&
         MG_2       =  5,   MG_N       =  6
      V_ANSI(MG_C) = "      "
      V_ANSI(MG_A) = "       "
      V_ANSI(MG_B) = "           "
      V_ANSI(MG_1) = "                "
      V_ANSI(MG_2) = "                   "
      V_ANSI(MG_N) = ""
      REG_GEN = REGISTRO
      PRINT #4,REG_GEN
   END SUB
1650   SUB PUT_HST(INTEGER MARGEN, STRING REGISTRO BY DESC)
      DECLARE STRING REG_GEN   , V_ANSI(6)
      DECLARE INTEGER   CONSTANT          &
         MG_C       =  1,   MG_A       =  2,&
         MG_B       =  3,   MG_1       =  4,&
         MG_2       =  5,   MG_N       =  6
      V_ANSI(MG_C) = "      "
      V_ANSI(MG_A) = "       "
      V_ANSI(MG_B) = "           "
      V_ANSI(MG_1) = "                "
      V_ANSI(MG_2) = "                   "
      V_ANSI(MG_N) = ""
      REG_GEN = V_ANSI(MARGEN) + REGISTRO
      PRINT #3,REG_GEN
   END SUB
1700  SUB PUT_CRT(INTEGER MARGEN, STRING REGISTRO BY DESC)
      DECLARE STRING REG_GEN   , V_ANSI(6)
      DECLARE INTEGER   CONSTANT          &
         MG_C       =  1,   MG_A       =  2,&
         MG_B       =  3,   MG_1       =  4,&
         MG_2       =  5,   MG_N       =  6
      V_ANSI(MG_C) = "      "
      V_ANSI(MG_A) = "       "
      V_ANSI(MG_B) = "           "
      V_ANSI(MG_1) = "                "
      V_ANSI(MG_2) = "                   "
      V_ANSI(MG_N) = ""
      REG_GEN = V_ANSI(MARGEN) + REGISTRO
 !!!      PRINT #5,"*% " + REG_GEN
      PRINT #5,REG_GEN
   END SUB
1800   SUB FIOREP (STRING ESTR_INGS BY DESC, STRING CRTR_ORIG BY DESC,&
          STRING CRTR_REEM BY DESC)

 !   Reemplaza en ESTR_INGS el CRTR_ORIG(caracter original)
 !   por CRTR_REEM(carater(es) de reemplazo)
 !
 !   Ejemplo de llamada de esta subrutina:
 !       PICT_FILD = 999999,999
 !      CALL FIOREP(PICT_FILD,",","V")
 !   Esta subrutina devuelve en PICT_FILD el valor 999999V999

   LARGO_STR% = LEN(ESTR_INGS) 
   VAR_AUX$ = ""
   FOR I% = 1 TO LARGO_STR%
      IF MID$(ESTR_INGS,I%,1) = CRTR_ORIG THEN
         VAR_AUX$ = VAR_AUX$ + CRTR_REEM
      ELSE
         VAR_AUX$ = VAR_AUX$ + MID$(ESTR_INGS,I%,1)
      END IF
   NEXT I%
   ESTR_INGS = VAR_AUX$
   END SUB
