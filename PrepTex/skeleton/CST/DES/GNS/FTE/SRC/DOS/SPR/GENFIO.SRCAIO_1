100
	DECLARE INTEGER NUMTOKEN,	SC_NUMTOKEN	,&
			SZTOKEN	, 	SC_SZTOKEN	,&
			TOKEN	,	SC_TOKEN 	,&
			P_P	,	SC_P_P		,&
			P_Q	,	SC_P_Q 		,&
			SZ_I_B

	DECLARE	STRING	C_Q	,	SC_C_Q		,&
			VALTOKEN,	SC_VALTOKEN	,&
			STRTOKEN

	DECLARE INTEGER	CONSTANT &
			KEYTOK = 1,	IDNTOK = 2	,&
			NUMTOK = 3,	STRTOK = 4	,&
			CHRTOK = 5,	EOLTOK = 6	,&
			ETXTOK = 7,	HTAB   = 9

	DECLARE INTEGER &
			LLAV_ALTE,	NEWE_NTRY 

	DECLARE STRING  &
			ASCI_BELL,	FILE_FDL	,&
			VARI_ABPA,	VARI_CIPA	,&
			REGI_STRO,	VARI_LLAV	,&
			O_L,		A_K		,&
			TIPO_ARCH,	NOMB_ARCH	,&
			V_M(5),		VARI_FIND	,&
			VARI_ALKY,	CIO_GLS_NAKY	,&
			A_T (20),	FILE_ALT	,&
			SIST_EMA			,&
			VARI_RESU,	AUXI_FDL	,&
			FILE_EDT,	SIZE_KEY	,&
			AUXI_ALTE,	WITH_DUPL	,&
			PARA_METRO,	W_DEP		,&
			W_VAR,		N_L


   DECLARE INTEGER CONSTANT &
			HTAB 	  =  9,	INX_NAME  =  1	,&
			INX_ORGA  =  2,	INX_FORM  =  3	,&
			INX_SIZE  =  4,	INX_KENA  =  5	,&
			INX_ACCE  =  6, INX_ALTE  =  7	,&
			INX_TIAR  =  8, INX_PNTO  =  7	,&
			NO	  =  0,	ZI	  =  1

210
 !==========================================================================
    DEF INTEGER NEXTTOKEN
	ON ERROR GO TO LABE_ERRO
	IF TOKEN = ETXTOK THEN
		NEXTTOKEN = ETXTOK
		GO TO LABE_ASIG
	END IF
        P_P = P_Q 
 LABE_SIGA:
	WHILE (MID$(I_B$,P_P,1) = " " OR ASCII(MID$(I_B$,P_P,1)) = HTAB) AND &
			P_P <= SZ_I_B
		P_P = P_P + 1
	NEXT
	P_Q = P_P 
	IF P_P > SZ_I_B OR I_B$ = "" THEN
		GET #C_FILE_FDL%
		SZ_I_B = RECOUNT
	     	MOVE FROM #C_FILE_FDL% , I_B$ = SZ_I_B
		P_P, P_Q  = 1
		GO TO LABE_SIGA
	END IF
	C_Q = MID$(I_B$,P_Q,1)
	IF (C_Q >= "A" AND C_Q <= "Z") OR (C_Q >= "a" AND C_Q <= "z") THEN
	         WHILE (MID$(I_B$,P_P,1) >= "A" AND MID$(I_B$,P_P,1) <= "Z" &
	            OR  MID$(I_B$,P_P,1)  = "_" 	  &
	            OR  MID$(I_B$,P_P,1)  = "0" 	  &
		    OR  MID$(I_B$,P_P,1) >= "a" AND &
		        MID$(I_B$,P_P,1) <= "z")
	            			P_P = P_P + 1
		 NEXT
	         SZTOKEN = P_P - P_Q
		 NEXTTOKEN = IDNTOK
	   	 VALTOKEN = MID$(I_B$,P_Q,SZTOKEN)
		 IF P_Q = 1 THEN
			NEWE_NTRY = ZI
		 END IF
	ELSE
	IF C_Q >= "0" AND C_Q <= "9" THEN
	          WHILE MID$(I_B$,P_P,1) >= "0" AND MID$(I_B$,P_P,1) <= "9"
		             P_P = P_P + 1
	          NEXT
	          SZTOKEN = P_P - P_Q
		  NEXTTOKEN = NUMTOK
		  VALTOKEN = MID$(I_B$,P_Q,SZTOKEN)
	          NUMTOKEN  = VAL(VALTOKEN)
	ELSE
	IF C_Q = '"'  OR C_Q = "'" THEN
		P_P = P_P + 1
	        WHILE MID$(I_B$,P_P,1) <> C_Q
  	              P_P = P_P + 1
	        NEXT
	        SZTOKEN = P_P - (P_Q + 1)
	        P_P = P_P + 1
		NEXTTOKEN = STRTOK
		STRTOKEN = MID$(I_B$,P_Q + 1,SZTOKEN)
		VALTOKEN = C_Q + STRTOKEN + C_Q
	ELSE
		NEXTTOKEN = CHRTOK
		VALTOKEN = MID$(I_B$,P_P,1)
		P_P = P_P + 1
		SZTOKEN = 1
	END IF
	END IF
	END IF
	GO TO LABE_ASIG
 LABE_ERRO:
	CLOSE #C_FILE_FDL%
	IF ERR = 11 THEN
		NEXTTOKEN = ETXTOK
	ELSE
		PRINT "ERROR(";ERR;") ";ERT$(ERR);" en linea ";erl;", MODULO ";ern$
	END IF
	RESUME 800
 LABE_ASIG:
	P_Q = P_P
800
	END DEF

 !==========================================================================

   DEF INTEGER FUNC_NAME
	NEWE_NTRY = NO
	WHILE NEWE_NTRY = NO AND TOKEN <> ETXTOK
		TOKEN = NEXTTOKEN
		IF VALTOKEN = "NAME" THEN
			TOKEN = NEXTTOKEN
			POSI_PNTO% = INSTR(1,STRTOKEN,".")
			POSI_DOSP% = INSTR(1,STRTOKEN,":")
			VARI_RESU = STRTOKEN
			IF POSI_PNTO% = 0 THEN
				CANT_CHAR% = LEN(STRTOKEN) - POSI_DOSP%
			ELSE
				CANT_CHAR% = POSI_PNTO% - POSI_DOSP% - 1
			END IF
			NOM_LOG$ = MID$(STRTOKEN,1,POSI_DOSP% - 1)
			NOM_FIS$ = MID$(STRTOKEN,POSI_DOSP% + 1,CANT_CHAR%)
			IF NOM_FIS$ <> "" THEN
				SIST_EMA = MID$(NOM_FIS$,1,3)
				A_T(INX_NAME) = MID$(NOM_FIS$,4,LEN(STRTOKEN) -3)
			ELSE
				SIST_EMA = MID$(NOM_LOG$,1,3)
				A_T(INX_NAME) = MID$(NOM_LOG$,4,LEN(STRTOKEN) -3)
			END IF	
			IF A_T(INX_NAME) = "" THEN
				CALL GENFIOERR(INX_NAME)
			END IF
		ELSE
		IF VALTOKEN = "ORGANIZATION" THEN
			TOKEN = NEXTTOKEN
			IF VALTOKEN = "indexed" THEN
				A_T(INX_TIAR) = "IDX"
			ELSE
			IF VALTOKEN = "sequential" THEN
				A_T(INX_TIAR) = "SEQ"
			ELSE
			IF VALTOKEN = "relative" THEN
				A_T(INX_TIAR) = "REL"
			END IF
			END IF
			END IF
		END IF
		END IF
	NEXT
   END DEF

 !==================================================================

   DEF INTEGER FUNC_REGI
	NEWE_NTRY = NO
	WHILE NEWE_NTRY = NO AND TOKEN <> ETXTOK
		TOKEN = NEXTTOKEN
		IF VALTOKEN = "FORMAT" THEN
			TOKEN = NEXTTOKEN
			A_T(INX_FORM) = VALTOKEN
		ELSE
		IF VALTOKEN = "SIZE" THEN
			TOKEN = NEXTTOKEN
			A_T(INX_SIZE) = VALTOKEN
		END IF
		END IF
	NEXT
   END DEF	

 !==================================================================
   DEF INTEGER FUNC_ALTE
	CIO_GLS_NAKY = "'" + A_K + SPACE$(31-LEN(A_K)) + "'"
	VARI_ALKY = &
	V_M(4) + 'IF FIO-AKEY = ' + CIO_GLS_NAKY + O_L +&
	V_M(5) +      'MOVE ' + A_K + ' TO FIO-VKEY'    	 + O_L +&
	V_M(5) +      "MOVE 'M" + MID$(VARI_RESU,1,LEN(VARI_RESU)-1)   +&
	 	      STR$(LLAV_ALTE) + 	"' TO FIO-VOID" + O_L +&
	V_M(5) +      'MOVE ' + A_T(INX_SIZE) + ' TO FIO-RLEN'   + O_L +&
	V_M(5) +      'MOVE ' + SIZE_KEY + ' TO FIO-KLEN'        + O_L +&
	V_M(4) +      'ELSE'
	PRINT #C_FILE_ALT%,VARI_ALKY

   END DEF
 !==================================================================

   DEF INTEGER FUNC_LLAV
      NEWE_NTRY = NO
      WITH_DUPL = ''
      WHILE NEWE_NTRY = NO AND TOKEN <> ETXTOK
	TOKEN = NEXTTOKEN
	IF VALTOKEN = 'NAME' THEN
	  TOKEN = NEXTTOKEN
	  A_K = STRTOKEN
	  IF LLAV_ALTE = 0 THEN
	    A_T(INX_KENA) = STRTOKEN

 !JSS^
 !	REGI_LLAV$ = MID$(STRTOKEN,1,3)
 !	DISG_LLAV$  = ""
 !	FOR I = 1 TO LEN(STRTOKEN)
 !		IF MID$(STRTOKEN,I,1) = "," THEN
 !			DISG_LLAV$ = DISG_LLAV$ + " IN " + SIST_EMA + "D" +&
 !				     REGI_LLAV$ + ", "
 !		ELSE
 !			DISG_LLAV$ = DISG_LLAV$ + MID$(STRTOKEN,I,1)
 !		END IF
 !	NEXT I
 !	DISG_LLAV$ = DISG_LLAV$ + " IN " + SIST_EMA + "D" + REGI_LLAV$

	REGI_LLAV$ = MID$(STRTOKEN,1,3)
	DISG_LLAV$  = "                     "
	FOR I = 1 TO LEN(STRTOKEN)
		IF MID$(STRTOKEN,I,1) = "," THEN
			DISG_LLAV$ = DISG_LLAV$ + " IN " +&
				SIST_EMA + "D" + REGI_LLAV$ + ", " + O_L +&
                                "                     "
		ELSE
			DISG_LLAV$ = DISG_LLAV$ + MID$(STRTOKEN,I,1)
		END IF
	NEXT I
	DISG_LLAV$ = DISG_LLAV$ + " IN " + SIST_EMA + "D" + REGI_LLAV$
	LLAV_COMP$ = DISG_LLAV$ + "."
	PRINT #C_FILE_ALT%,LLAV_COMP$
 !JSSv


	    A_T(INX_ALTE) = "	MOVE WSS-VKEY 	TO	" + STRTOKEN
	    WHILE NEWE_NTRY = NO AND TOKEN <> ETXTOK AND VALTOKEN <> "SEG0_LENGTH"
	    	TOKEN = NEXTTOKEN
	    NEXT
	    TOKEN = NEXTTOKEN
	    SIZE_KEY = SIZE_KEY + VALTOKEN
	ELSE
	    A_T(INX_ALTE) = A_T(INX_ALTE) + O_L + V_M(4) + V_M(2) + STRTOKEN
	    AUXI_ALTE = V_M(3) + "ALTERNATE RECORD KEY IS " + A_K +&
	    		" IN " + SIST_EMA + A_T(INX_NAME)
	    IF LLAV_ALTE = 1 THEN
		PRINT #C_FILE_ALT%,&
                V_M(3) + 'IF ( ( FIO-GET-KEY-ALT NOT > FIO-CMND )   AND'+ O_L +&
		V_M(3) + '     ( FIO-CMND NOT > FIO-GET-UPD-ALT ) ) OR' + O_L +&
		V_M(3) + '   ( ( FIO-FND-EQL-ALT NOT > FIO-CMND )   AND'+ O_L +&
		V_M(3) + '     ( FIO-CMND NOT > FIO-FND-NLS-ALT ) )'
	    END IF
		INDI_ACCI = FUNC_ALTE
	END IF
	ELSE
	IF VALTOKEN = 'DUPLICATES' THEN
		TOKEN = NEXTTOKEN
		IF VALTOKEN = 'yes' AND LLAV_ALTE <> 0 THEN
			WITH_DUPL = ' WITH DUPLICATES '
		END IF
	END IF
	END IF
      NEXT
	AUXI_ALTE = AUXI_ALTE + WITH_DUPL
	LLAV_ALTE = LLAV_ALTE + 1
    END DEF

 !==================================================================

   DEF INTEGER GRAB_ARC

 !JSS	FILE_EDT = 'FIO' + AUXI_FDL + '.EDT'
	FILE_EDT = 'SIO' + AUXI_FDL + '.EDT'
	OPEN FILE_EDT FOR OUTPUT AS FILE #C_FILE_EDT%,ORGANIZATION SEQUENTIAL &
		VARIABLE , RECORDSIZE 255, RECORDTYPE ANY

	FOR I = 1 TO 7
	 	PRINT #C_FILE_EDT%, 'FIND "^key^"'
	 	PRINT #C_FILE_EDT%, 'DELETE'
	 	PRINT #C_FILE_EDT%, 'INC ' + FILE_ALT
        NEXT I
	PRINT #C_FILE_EDT%, 'S/^reg^/' + A_T(INX_NAME)	+ '/W/NOTYPE'
 !JSS	PRINT #C_FILE_EDT%, 'S/^key^/' + A_T(INX_KENA)	+ '/W/NOTYPE'
 !	PRINT #C_FILE_EDT%, 'S/^key^/' + LLAV_COMP$	+ '/W/NOTYPE'

 !	PRINT #C_FILE_EDT%, 'S/^var^/' + W_VAR		+ '/W/NOTYPE'
	PRINT #C_FILE_EDT%, 'S/^rsz^/' + A_T(INX_SIZE)	+ '/W/NOTYPE'
 !	PRINT #C_FILE_EDT%, 'S/^dep^/' + W_DEP		+ '/W/NOTYPE'
	PRINT #C_FILE_EDT%, 'S/^sis^/' + SIST_EMA	+ '/W/NOTYPE'
	PRINT #C_FILE_EDT%, 'S/^vid^/' + VARI_RESU	+ '/W/NOTYPE'
	PRINT #C_FILE_EDT%, 'S/^ksz^/' + SIZE_KEY	+ '/W/NOTYPE'
	PRINT #C_FILE_EDT%, 'EXIT'
	CLOSE #C_FILE_EDT%
   END DEF

 ! ------------------------------------------------------------------
 !               MODULO PRINCIPAL
 ! __________________________________________________________________


	ON ERROR GO TO  LABE_BADD
	ASCI_BELL = CHR$(07)
	O_L = CHR$(13) + CHR$(10)
	C_FILE_FDL% = 1	
	C_FILE_ALT% = 3
	C_FILE_EDT% = 6
	V_M(1) = "      "
	V_M(2) = "	 "
	V_M(3) = "           "
	V_M(4) = "              "
	V_M(5) = "                 "
	SIZE_KEY = "0"

	CALL LIB$GET_SYMBOL("PTH",FILE_FDL)
	CALL LIB$GET_SYMBOL("FIL",AUXI_FDL)

	OPEN FILE_FDL FOR INPUT  AS FILE #C_FILE_FDL%,	RECORDSIZE 255, &
	             ORGANIZATION SEQUENTIAL VARIABLE, 	RECORDTYPE ANY

	FILE_ALT = 'SIO' + AUXI_FDL + ".ALT"
	OPEN FILE_ALT FOR OUTPUT AS FILE #C_FILE_ALT%,	RECORDSIZE 255,	&
		     ORGANIZATION SEQUENTIAL VARIABLE,	RECORDTYPE ANY

	GET #C_FILE_FDL%
	SZ_I_B  = RECOUNT
	MOVE FROM #C_FILE_FDL% , I_B$ = SZ_I_B
	P_P,P_Q = 1
	WHILE TOKEN <> ETXTOK
		IF TOKEN = IDNTOK AND VALTOKEN = "FILE" THEN
			INDI_ACCI = FUNC_NAME
		ELSE
		IF TOKEN = IDNTOK AND VALTOKEN = "RECORD" THEN
			INDI_ACCI = FUNC_REGI
		ELSE
		IF TOKEN = IDNTOK AND VALTOKEN = "KEY" THEN
			INDI_ACCI = FUNC_LLAV
		ELSE
			TOKEN = NEXTTOKEN
		END IF
		END IF
		END IF
	NEXT

	TIPO_ARCH = A_T(INX_TIAR)
	NOMB_ARCH =  SIST_EMA + A_T(INX_NAME)

	IF A_T(INX_SIZE) = "" THEN
		CALL GENFIOERR(INX_SIZE)
	ELSE
	IF TIPO_ARCH = "IDX" AND A_T(INX_KENA) = "" THEN
		CALL GENFIOERR(INX_KENA)
	END IF
	END IF
	IF TIPO_ARCH = "IDX" THEN
		A_T(INX_ALTE) = A_T(INX_ALTE) + "."
	END IF
	IF A_T(INX_FORM) = "variable" THEN
		W_VAR = "VARYING TO "
		W_DEP = " DEPENDING FIO-RLEN"
	ELSE
		W_VAR = ""
		W_DEP = ""
	END IF
	
	INDI_ACCI = GRAB_ARC
	IF LLAV_ALTE > 1 THEN
		PRINT #C_FILE_ALT%,V_M(5) + "DISPLAY 'ERROR EN LLAVE " +&
			"ALT.: ' FIO-AKEY" + O_L +&
			V_M(5) + 'GOBACK.'
	END IF
	CLOSE #C_FILE_ALT%
 !JSS
 !JSS	PARA_METRO = '$ EDTCIO ' + AUXI_FDL + ' ' + TIPO_ARCH + ' ' + SIST_EMA + ' ' +&
 !JSS			   A_T(INX_NAME)
 !JSS	CALL LIB$DO_COMMAND(PARA_METRO)

	CALL LIB$SET_SYMBOL BY DESC ('EDT',AUXI_FDL)
	CALL LIB$SET_SYMBOL BY DESC ('ORG',TIPO_ARCH)
	CALL LIB$SET_SYMBOL BY DESC ('SIS',SIST_EMA)
	CALL LIB$SET_SYMBOL BY DESC ('REG',A_T(INX_NAME))
	GO TO LABE_ATRA
		
 LABE_BADD:
	PRINT ASCI_BELL,ASCI_BELL,ASCI_BELL
	IF ERR = 2 THEN
		PRINT FILE_FDL, " : NOMBRE DE ARCHIVO ILEGAL"
	ELSE 
	IF ERR = 5 THEN
		PRINT FILE_FDL, " ARCHIVO INEXISTENTE       "
	ELSE
		PRINT "CODIGO : ",ERR
		PRINT "MENSAJE :",ERT$(ERR)
	END IF
	END IF
	RESUME 999
999
 LABE_ATRA:
 END
